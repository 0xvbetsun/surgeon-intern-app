// Code generated by SQLBoiler 4.8.3 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// OrthopedicSurgeryActivity is an object representing the database table.
type OrthopedicSurgeryActivity struct {
	ID                      string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	OccurredAt              time.Time   `boil:"occurred_at" json:"occurred_at" toml:"occurred_at" yaml:"occurred_at"`
	CreatedAt               time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	CaseNotes               string      `boil:"case_notes" json:"case_notes" toml:"case_notes" yaml:"case_notes"`
	PatientAge              int         `boil:"patient_age" json:"patient_age" toml:"patient_age" yaml:"patient_age"`
	PatientGender           string      `boil:"patient_gender" json:"patient_gender" toml:"patient_gender" yaml:"patient_gender"`
	ResidentID              string      `boil:"resident_id" json:"resident_id" toml:"resident_id" yaml:"resident_id"`
	SupervisorID            null.String `boil:"supervisor_id" json:"supervisor_id,omitempty" toml:"supervisor_id" yaml:"supervisor_id,omitempty"`
	OperatorID              null.String `boil:"operator_id" json:"operator_id,omitempty" toml:"operator_id" yaml:"operator_id,omitempty"`
	AssistantID             null.String `boil:"assistant_id" json:"assistant_id,omitempty" toml:"assistant_id" yaml:"assistant_id,omitempty"`
	Comments                string      `boil:"comments" json:"comments" toml:"comments" yaml:"comments"`
	Complications           string      `boil:"complications" json:"complications" toml:"complications" yaml:"complications"`
	Annotations             types.JSON  `boil:"annotations" json:"annotations" toml:"annotations" yaml:"annotations"`
	DopsRequested           bool        `boil:"dops_requested" json:"dops_requested" toml:"dops_requested" yaml:"dops_requested"`
	ReviewRequested         bool        `boil:"review_requested" json:"review_requested" toml:"review_requested" yaml:"review_requested"`
	HasDopsConnection       bool        `boil:"has_dops_connection" json:"has_dops_connection" toml:"has_dops_connection" yaml:"has_dops_connection"`
	PracticalActivityTypeID int         `boil:"practical_activity_type_id" json:"practical_activity_type_id" toml:"practical_activity_type_id" yaml:"practical_activity_type_id"`
	InProgress              bool        `boil:"in_progress" json:"in_progress" toml:"in_progress" yaml:"in_progress"`
	ActiveStep              int         `boil:"active_step" json:"active_step" toml:"active_step" yaml:"active_step"`
	CompletedStep           int         `boil:"completed_step" json:"completed_step" toml:"completed_step" yaml:"completed_step"`

	R *orthopedicSurgeryActivityR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L orthopedicSurgeryActivityL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var OrthopedicSurgeryActivityColumns = struct {
	ID                      string
	OccurredAt              string
	CreatedAt               string
	CaseNotes               string
	PatientAge              string
	PatientGender           string
	ResidentID              string
	SupervisorID            string
	OperatorID              string
	AssistantID             string
	Comments                string
	Complications           string
	Annotations             string
	DopsRequested           string
	ReviewRequested         string
	HasDopsConnection       string
	PracticalActivityTypeID string
	InProgress              string
	ActiveStep              string
	CompletedStep           string
}{
	ID:                      "id",
	OccurredAt:              "occurred_at",
	CreatedAt:               "created_at",
	CaseNotes:               "case_notes",
	PatientAge:              "patient_age",
	PatientGender:           "patient_gender",
	ResidentID:              "resident_id",
	SupervisorID:            "supervisor_id",
	OperatorID:              "operator_id",
	AssistantID:             "assistant_id",
	Comments:                "comments",
	Complications:           "complications",
	Annotations:             "annotations",
	DopsRequested:           "dops_requested",
	ReviewRequested:         "review_requested",
	HasDopsConnection:       "has_dops_connection",
	PracticalActivityTypeID: "practical_activity_type_id",
	InProgress:              "in_progress",
	ActiveStep:              "active_step",
	CompletedStep:           "completed_step",
}

var OrthopedicSurgeryActivityTableColumns = struct {
	ID                      string
	OccurredAt              string
	CreatedAt               string
	CaseNotes               string
	PatientAge              string
	PatientGender           string
	ResidentID              string
	SupervisorID            string
	OperatorID              string
	AssistantID             string
	Comments                string
	Complications           string
	Annotations             string
	DopsRequested           string
	ReviewRequested         string
	HasDopsConnection       string
	PracticalActivityTypeID string
	InProgress              string
	ActiveStep              string
	CompletedStep           string
}{
	ID:                      "orthopedic_surgery_activities.id",
	OccurredAt:              "orthopedic_surgery_activities.occurred_at",
	CreatedAt:               "orthopedic_surgery_activities.created_at",
	CaseNotes:               "orthopedic_surgery_activities.case_notes",
	PatientAge:              "orthopedic_surgery_activities.patient_age",
	PatientGender:           "orthopedic_surgery_activities.patient_gender",
	ResidentID:              "orthopedic_surgery_activities.resident_id",
	SupervisorID:            "orthopedic_surgery_activities.supervisor_id",
	OperatorID:              "orthopedic_surgery_activities.operator_id",
	AssistantID:             "orthopedic_surgery_activities.assistant_id",
	Comments:                "orthopedic_surgery_activities.comments",
	Complications:           "orthopedic_surgery_activities.complications",
	Annotations:             "orthopedic_surgery_activities.annotations",
	DopsRequested:           "orthopedic_surgery_activities.dops_requested",
	ReviewRequested:         "orthopedic_surgery_activities.review_requested",
	HasDopsConnection:       "orthopedic_surgery_activities.has_dops_connection",
	PracticalActivityTypeID: "orthopedic_surgery_activities.practical_activity_type_id",
	InProgress:              "orthopedic_surgery_activities.in_progress",
	ActiveStep:              "orthopedic_surgery_activities.active_step",
	CompletedStep:           "orthopedic_surgery_activities.completed_step",
}

// Generated where

var OrthopedicSurgeryActivityWhere = struct {
	ID                      whereHelperstring
	OccurredAt              whereHelpertime_Time
	CreatedAt               whereHelpertime_Time
	CaseNotes               whereHelperstring
	PatientAge              whereHelperint
	PatientGender           whereHelperstring
	ResidentID              whereHelperstring
	SupervisorID            whereHelpernull_String
	OperatorID              whereHelpernull_String
	AssistantID             whereHelpernull_String
	Comments                whereHelperstring
	Complications           whereHelperstring
	Annotations             whereHelpertypes_JSON
	DopsRequested           whereHelperbool
	ReviewRequested         whereHelperbool
	HasDopsConnection       whereHelperbool
	PracticalActivityTypeID whereHelperint
	InProgress              whereHelperbool
	ActiveStep              whereHelperint
	CompletedStep           whereHelperint
}{
	ID:                      whereHelperstring{field: "\"orthopedic_surgery_activities\".\"id\""},
	OccurredAt:              whereHelpertime_Time{field: "\"orthopedic_surgery_activities\".\"occurred_at\""},
	CreatedAt:               whereHelpertime_Time{field: "\"orthopedic_surgery_activities\".\"created_at\""},
	CaseNotes:               whereHelperstring{field: "\"orthopedic_surgery_activities\".\"case_notes\""},
	PatientAge:              whereHelperint{field: "\"orthopedic_surgery_activities\".\"patient_age\""},
	PatientGender:           whereHelperstring{field: "\"orthopedic_surgery_activities\".\"patient_gender\""},
	ResidentID:              whereHelperstring{field: "\"orthopedic_surgery_activities\".\"resident_id\""},
	SupervisorID:            whereHelpernull_String{field: "\"orthopedic_surgery_activities\".\"supervisor_id\""},
	OperatorID:              whereHelpernull_String{field: "\"orthopedic_surgery_activities\".\"operator_id\""},
	AssistantID:             whereHelpernull_String{field: "\"orthopedic_surgery_activities\".\"assistant_id\""},
	Comments:                whereHelperstring{field: "\"orthopedic_surgery_activities\".\"comments\""},
	Complications:           whereHelperstring{field: "\"orthopedic_surgery_activities\".\"complications\""},
	Annotations:             whereHelpertypes_JSON{field: "\"orthopedic_surgery_activities\".\"annotations\""},
	DopsRequested:           whereHelperbool{field: "\"orthopedic_surgery_activities\".\"dops_requested\""},
	ReviewRequested:         whereHelperbool{field: "\"orthopedic_surgery_activities\".\"review_requested\""},
	HasDopsConnection:       whereHelperbool{field: "\"orthopedic_surgery_activities\".\"has_dops_connection\""},
	PracticalActivityTypeID: whereHelperint{field: "\"orthopedic_surgery_activities\".\"practical_activity_type_id\""},
	InProgress:              whereHelperbool{field: "\"orthopedic_surgery_activities\".\"in_progress\""},
	ActiveStep:              whereHelperint{field: "\"orthopedic_surgery_activities\".\"active_step\""},
	CompletedStep:           whereHelperint{field: "\"orthopedic_surgery_activities\".\"completed_step\""},
}

// OrthopedicSurgeryActivityRels is where relationship names are stored.
var OrthopedicSurgeryActivityRels = struct {
	Assistant                            string
	Operator                             string
	PracticalActivityType                string
	Resident                             string
	Supervisor                           string
	DopsEvaluation                       string
	OrthopedicSurgeryLogbookEntry        string
	OrthopedicSurgeriesActivityReview    string
	OrthopedicSurgeryActivitiesSurgeries string
}{
	Assistant:                            "Assistant",
	Operator:                             "Operator",
	PracticalActivityType:                "PracticalActivityType",
	Resident:                             "Resident",
	Supervisor:                           "Supervisor",
	DopsEvaluation:                       "DopsEvaluation",
	OrthopedicSurgeryLogbookEntry:        "OrthopedicSurgeryLogbookEntry",
	OrthopedicSurgeriesActivityReview:    "OrthopedicSurgeriesActivityReview",
	OrthopedicSurgeryActivitiesSurgeries: "OrthopedicSurgeryActivitiesSurgeries",
}

// orthopedicSurgeryActivityR is where relationships are stored.
type orthopedicSurgeryActivityR struct {
	Assistant                            *User                                   `boil:"Assistant" json:"Assistant" toml:"Assistant" yaml:"Assistant"`
	Operator                             *User                                   `boil:"Operator" json:"Operator" toml:"Operator" yaml:"Operator"`
	PracticalActivityType                *PracticalActivityType                  `boil:"PracticalActivityType" json:"PracticalActivityType" toml:"PracticalActivityType" yaml:"PracticalActivityType"`
	Resident                             *User                                   `boil:"Resident" json:"Resident" toml:"Resident" yaml:"Resident"`
	Supervisor                           *User                                   `boil:"Supervisor" json:"Supervisor" toml:"Supervisor" yaml:"Supervisor"`
	DopsEvaluation                       *DopsEvaluation                         `boil:"DopsEvaluation" json:"DopsEvaluation" toml:"DopsEvaluation" yaml:"DopsEvaluation"`
	OrthopedicSurgeryLogbookEntry        *LogbookEntry                           `boil:"OrthopedicSurgeryLogbookEntry" json:"OrthopedicSurgeryLogbookEntry" toml:"OrthopedicSurgeryLogbookEntry" yaml:"OrthopedicSurgeryLogbookEntry"`
	OrthopedicSurgeriesActivityReview    *OrthopedicSurgeriesActivityReview      `boil:"OrthopedicSurgeriesActivityReview" json:"OrthopedicSurgeriesActivityReview" toml:"OrthopedicSurgeriesActivityReview" yaml:"OrthopedicSurgeriesActivityReview"`
	OrthopedicSurgeryActivitiesSurgeries OrthopedicSurgeryActivitiesSurgerySlice `boil:"OrthopedicSurgeryActivitiesSurgeries" json:"OrthopedicSurgeryActivitiesSurgeries" toml:"OrthopedicSurgeryActivitiesSurgeries" yaml:"OrthopedicSurgeryActivitiesSurgeries"`
}

// NewStruct creates a new relationship struct
func (*orthopedicSurgeryActivityR) NewStruct() *orthopedicSurgeryActivityR {
	return &orthopedicSurgeryActivityR{}
}

// orthopedicSurgeryActivityL is where Load methods for each relationship are stored.
type orthopedicSurgeryActivityL struct{}

var (
	orthopedicSurgeryActivityAllColumns            = []string{"id", "occurred_at", "created_at", "case_notes", "patient_age", "patient_gender", "resident_id", "supervisor_id", "operator_id", "assistant_id", "comments", "complications", "annotations", "dops_requested", "review_requested", "has_dops_connection", "practical_activity_type_id", "in_progress", "active_step", "completed_step"}
	orthopedicSurgeryActivityColumnsWithoutDefault = []string{"case_notes", "patient_age", "patient_gender", "resident_id", "supervisor_id", "operator_id", "assistant_id", "practical_activity_type_id"}
	orthopedicSurgeryActivityColumnsWithDefault    = []string{"id", "occurred_at", "created_at", "comments", "complications", "annotations", "dops_requested", "review_requested", "has_dops_connection", "in_progress", "active_step", "completed_step"}
	orthopedicSurgeryActivityPrimaryKeyColumns     = []string{"id"}
)

type (
	// OrthopedicSurgeryActivitySlice is an alias for a slice of pointers to OrthopedicSurgeryActivity.
	// This should almost always be used instead of []OrthopedicSurgeryActivity.
	OrthopedicSurgeryActivitySlice []*OrthopedicSurgeryActivity
	// OrthopedicSurgeryActivityHook is the signature for custom OrthopedicSurgeryActivity hook methods
	OrthopedicSurgeryActivityHook func(context.Context, boil.ContextExecutor, *OrthopedicSurgeryActivity) error

	orthopedicSurgeryActivityQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	orthopedicSurgeryActivityType                 = reflect.TypeOf(&OrthopedicSurgeryActivity{})
	orthopedicSurgeryActivityMapping              = queries.MakeStructMapping(orthopedicSurgeryActivityType)
	orthopedicSurgeryActivityPrimaryKeyMapping, _ = queries.BindMapping(orthopedicSurgeryActivityType, orthopedicSurgeryActivityMapping, orthopedicSurgeryActivityPrimaryKeyColumns)
	orthopedicSurgeryActivityInsertCacheMut       sync.RWMutex
	orthopedicSurgeryActivityInsertCache          = make(map[string]insertCache)
	orthopedicSurgeryActivityUpdateCacheMut       sync.RWMutex
	orthopedicSurgeryActivityUpdateCache          = make(map[string]updateCache)
	orthopedicSurgeryActivityUpsertCacheMut       sync.RWMutex
	orthopedicSurgeryActivityUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var orthopedicSurgeryActivityBeforeInsertHooks []OrthopedicSurgeryActivityHook
var orthopedicSurgeryActivityBeforeUpdateHooks []OrthopedicSurgeryActivityHook
var orthopedicSurgeryActivityBeforeDeleteHooks []OrthopedicSurgeryActivityHook
var orthopedicSurgeryActivityBeforeUpsertHooks []OrthopedicSurgeryActivityHook

var orthopedicSurgeryActivityAfterInsertHooks []OrthopedicSurgeryActivityHook
var orthopedicSurgeryActivityAfterSelectHooks []OrthopedicSurgeryActivityHook
var orthopedicSurgeryActivityAfterUpdateHooks []OrthopedicSurgeryActivityHook
var orthopedicSurgeryActivityAfterDeleteHooks []OrthopedicSurgeryActivityHook
var orthopedicSurgeryActivityAfterUpsertHooks []OrthopedicSurgeryActivityHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *OrthopedicSurgeryActivity) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeryActivityBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *OrthopedicSurgeryActivity) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeryActivityBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *OrthopedicSurgeryActivity) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeryActivityBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *OrthopedicSurgeryActivity) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeryActivityBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *OrthopedicSurgeryActivity) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeryActivityAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *OrthopedicSurgeryActivity) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeryActivityAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *OrthopedicSurgeryActivity) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeryActivityAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *OrthopedicSurgeryActivity) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeryActivityAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *OrthopedicSurgeryActivity) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeryActivityAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddOrthopedicSurgeryActivityHook registers your hook function for all future operations.
func AddOrthopedicSurgeryActivityHook(hookPoint boil.HookPoint, orthopedicSurgeryActivityHook OrthopedicSurgeryActivityHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		orthopedicSurgeryActivityBeforeInsertHooks = append(orthopedicSurgeryActivityBeforeInsertHooks, orthopedicSurgeryActivityHook)
	case boil.BeforeUpdateHook:
		orthopedicSurgeryActivityBeforeUpdateHooks = append(orthopedicSurgeryActivityBeforeUpdateHooks, orthopedicSurgeryActivityHook)
	case boil.BeforeDeleteHook:
		orthopedicSurgeryActivityBeforeDeleteHooks = append(orthopedicSurgeryActivityBeforeDeleteHooks, orthopedicSurgeryActivityHook)
	case boil.BeforeUpsertHook:
		orthopedicSurgeryActivityBeforeUpsertHooks = append(orthopedicSurgeryActivityBeforeUpsertHooks, orthopedicSurgeryActivityHook)
	case boil.AfterInsertHook:
		orthopedicSurgeryActivityAfterInsertHooks = append(orthopedicSurgeryActivityAfterInsertHooks, orthopedicSurgeryActivityHook)
	case boil.AfterSelectHook:
		orthopedicSurgeryActivityAfterSelectHooks = append(orthopedicSurgeryActivityAfterSelectHooks, orthopedicSurgeryActivityHook)
	case boil.AfterUpdateHook:
		orthopedicSurgeryActivityAfterUpdateHooks = append(orthopedicSurgeryActivityAfterUpdateHooks, orthopedicSurgeryActivityHook)
	case boil.AfterDeleteHook:
		orthopedicSurgeryActivityAfterDeleteHooks = append(orthopedicSurgeryActivityAfterDeleteHooks, orthopedicSurgeryActivityHook)
	case boil.AfterUpsertHook:
		orthopedicSurgeryActivityAfterUpsertHooks = append(orthopedicSurgeryActivityAfterUpsertHooks, orthopedicSurgeryActivityHook)
	}
}

// One returns a single orthopedicSurgeryActivity record from the query.
func (q orthopedicSurgeryActivityQuery) One(ctx context.Context, exec boil.ContextExecutor) (*OrthopedicSurgeryActivity, error) {
	o := &OrthopedicSurgeryActivity{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for orthopedic_surgery_activities")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all OrthopedicSurgeryActivity records from the query.
func (q orthopedicSurgeryActivityQuery) All(ctx context.Context, exec boil.ContextExecutor) (OrthopedicSurgeryActivitySlice, error) {
	var o []*OrthopedicSurgeryActivity

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to OrthopedicSurgeryActivity slice")
	}

	if len(orthopedicSurgeryActivityAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all OrthopedicSurgeryActivity records in the query.
func (q orthopedicSurgeryActivityQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count orthopedic_surgery_activities rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q orthopedicSurgeryActivityQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if orthopedic_surgery_activities exists")
	}

	return count > 0, nil
}

// Assistant pointed to by the foreign key.
func (o *OrthopedicSurgeryActivity) Assistant(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.AssistantID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	return query
}

// Operator pointed to by the foreign key.
func (o *OrthopedicSurgeryActivity) Operator(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.OperatorID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	return query
}

// PracticalActivityType pointed to by the foreign key.
func (o *OrthopedicSurgeryActivity) PracticalActivityType(mods ...qm.QueryMod) practicalActivityTypeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.PracticalActivityTypeID),
	}

	queryMods = append(queryMods, mods...)

	query := PracticalActivityTypes(queryMods...)
	queries.SetFrom(query.Query, "\"practical_activity_types\"")

	return query
}

// Resident pointed to by the foreign key.
func (o *OrthopedicSurgeryActivity) Resident(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ResidentID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	return query
}

// Supervisor pointed to by the foreign key.
func (o *OrthopedicSurgeryActivity) Supervisor(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.SupervisorID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	return query
}

// DopsEvaluation pointed to by the foreign key.
func (o *OrthopedicSurgeryActivity) DopsEvaluation(mods ...qm.QueryMod) dopsEvaluationQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"orthopedic_surgery_activity_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	query := DopsEvaluations(queryMods...)
	queries.SetFrom(query.Query, "\"dops_evaluations\"")

	return query
}

// OrthopedicSurgeryLogbookEntry pointed to by the foreign key.
func (o *OrthopedicSurgeryActivity) OrthopedicSurgeryLogbookEntry(mods ...qm.QueryMod) logbookEntryQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"orthopedic_surgery_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	query := LogbookEntries(queryMods...)
	queries.SetFrom(query.Query, "\"logbook_entries\"")

	return query
}

// OrthopedicSurgeriesActivityReview pointed to by the foreign key.
func (o *OrthopedicSurgeryActivity) OrthopedicSurgeriesActivityReview(mods ...qm.QueryMod) orthopedicSurgeriesActivityReviewQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"orthopedic_surgery_activity_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	query := OrthopedicSurgeriesActivityReviews(queryMods...)
	queries.SetFrom(query.Query, "\"orthopedic_surgeries_activity_review\"")

	return query
}

// OrthopedicSurgeryActivitiesSurgeries retrieves all the orthopedic_surgery_activities_surgery's OrthopedicSurgeryActivitiesSurgeries with an executor.
func (o *OrthopedicSurgeryActivity) OrthopedicSurgeryActivitiesSurgeries(mods ...qm.QueryMod) orthopedicSurgeryActivitiesSurgeryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"orthopedic_surgery_activities_surgeries\".\"orthopedic_surgery_activity_id\"=?", o.ID),
	)

	query := OrthopedicSurgeryActivitiesSurgeries(queryMods...)
	queries.SetFrom(query.Query, "\"orthopedic_surgery_activities_surgeries\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"orthopedic_surgery_activities_surgeries\".*"})
	}

	return query
}

// LoadAssistant allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (orthopedicSurgeryActivityL) LoadAssistant(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrthopedicSurgeryActivity interface{}, mods queries.Applicator) error {
	var slice []*OrthopedicSurgeryActivity
	var object *OrthopedicSurgeryActivity

	if singular {
		object = maybeOrthopedicSurgeryActivity.(*OrthopedicSurgeryActivity)
	} else {
		slice = *maybeOrthopedicSurgeryActivity.(*[]*OrthopedicSurgeryActivity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orthopedicSurgeryActivityR{}
		}
		if !queries.IsNil(object.AssistantID) {
			args = append(args, object.AssistantID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orthopedicSurgeryActivityR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.AssistantID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.AssistantID) {
				args = append(args, obj.AssistantID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(orthopedicSurgeryActivityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Assistant = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.AssistantOrthopedicSurgeryActivities = append(foreign.R.AssistantOrthopedicSurgeryActivities, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.AssistantID, foreign.ID) {
				local.R.Assistant = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.AssistantOrthopedicSurgeryActivities = append(foreign.R.AssistantOrthopedicSurgeryActivities, local)
				break
			}
		}
	}

	return nil
}

// LoadOperator allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (orthopedicSurgeryActivityL) LoadOperator(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrthopedicSurgeryActivity interface{}, mods queries.Applicator) error {
	var slice []*OrthopedicSurgeryActivity
	var object *OrthopedicSurgeryActivity

	if singular {
		object = maybeOrthopedicSurgeryActivity.(*OrthopedicSurgeryActivity)
	} else {
		slice = *maybeOrthopedicSurgeryActivity.(*[]*OrthopedicSurgeryActivity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orthopedicSurgeryActivityR{}
		}
		if !queries.IsNil(object.OperatorID) {
			args = append(args, object.OperatorID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orthopedicSurgeryActivityR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OperatorID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.OperatorID) {
				args = append(args, obj.OperatorID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(orthopedicSurgeryActivityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Operator = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.OperatorOrthopedicSurgeryActivities = append(foreign.R.OperatorOrthopedicSurgeryActivities, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.OperatorID, foreign.ID) {
				local.R.Operator = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.OperatorOrthopedicSurgeryActivities = append(foreign.R.OperatorOrthopedicSurgeryActivities, local)
				break
			}
		}
	}

	return nil
}

// LoadPracticalActivityType allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (orthopedicSurgeryActivityL) LoadPracticalActivityType(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrthopedicSurgeryActivity interface{}, mods queries.Applicator) error {
	var slice []*OrthopedicSurgeryActivity
	var object *OrthopedicSurgeryActivity

	if singular {
		object = maybeOrthopedicSurgeryActivity.(*OrthopedicSurgeryActivity)
	} else {
		slice = *maybeOrthopedicSurgeryActivity.(*[]*OrthopedicSurgeryActivity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orthopedicSurgeryActivityR{}
		}
		args = append(args, object.PracticalActivityTypeID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orthopedicSurgeryActivityR{}
			}

			for _, a := range args {
				if a == obj.PracticalActivityTypeID {
					continue Outer
				}
			}

			args = append(args, obj.PracticalActivityTypeID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`practical_activity_types`),
		qm.WhereIn(`practical_activity_types.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PracticalActivityType")
	}

	var resultSlice []*PracticalActivityType
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PracticalActivityType")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for practical_activity_types")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for practical_activity_types")
	}

	if len(orthopedicSurgeryActivityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PracticalActivityType = foreign
		if foreign.R == nil {
			foreign.R = &practicalActivityTypeR{}
		}
		foreign.R.OrthopedicSurgeryActivities = append(foreign.R.OrthopedicSurgeryActivities, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PracticalActivityTypeID == foreign.ID {
				local.R.PracticalActivityType = foreign
				if foreign.R == nil {
					foreign.R = &practicalActivityTypeR{}
				}
				foreign.R.OrthopedicSurgeryActivities = append(foreign.R.OrthopedicSurgeryActivities, local)
				break
			}
		}
	}

	return nil
}

// LoadResident allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (orthopedicSurgeryActivityL) LoadResident(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrthopedicSurgeryActivity interface{}, mods queries.Applicator) error {
	var slice []*OrthopedicSurgeryActivity
	var object *OrthopedicSurgeryActivity

	if singular {
		object = maybeOrthopedicSurgeryActivity.(*OrthopedicSurgeryActivity)
	} else {
		slice = *maybeOrthopedicSurgeryActivity.(*[]*OrthopedicSurgeryActivity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orthopedicSurgeryActivityR{}
		}
		args = append(args, object.ResidentID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orthopedicSurgeryActivityR{}
			}

			for _, a := range args {
				if a == obj.ResidentID {
					continue Outer
				}
			}

			args = append(args, obj.ResidentID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(orthopedicSurgeryActivityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Resident = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.ResidentOrthopedicSurgeryActivities = append(foreign.R.ResidentOrthopedicSurgeryActivities, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ResidentID == foreign.ID {
				local.R.Resident = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.ResidentOrthopedicSurgeryActivities = append(foreign.R.ResidentOrthopedicSurgeryActivities, local)
				break
			}
		}
	}

	return nil
}

// LoadSupervisor allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (orthopedicSurgeryActivityL) LoadSupervisor(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrthopedicSurgeryActivity interface{}, mods queries.Applicator) error {
	var slice []*OrthopedicSurgeryActivity
	var object *OrthopedicSurgeryActivity

	if singular {
		object = maybeOrthopedicSurgeryActivity.(*OrthopedicSurgeryActivity)
	} else {
		slice = *maybeOrthopedicSurgeryActivity.(*[]*OrthopedicSurgeryActivity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orthopedicSurgeryActivityR{}
		}
		if !queries.IsNil(object.SupervisorID) {
			args = append(args, object.SupervisorID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orthopedicSurgeryActivityR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.SupervisorID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.SupervisorID) {
				args = append(args, obj.SupervisorID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(orthopedicSurgeryActivityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Supervisor = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.SupervisorOrthopedicSurgeryActivities = append(foreign.R.SupervisorOrthopedicSurgeryActivities, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.SupervisorID, foreign.ID) {
				local.R.Supervisor = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.SupervisorOrthopedicSurgeryActivities = append(foreign.R.SupervisorOrthopedicSurgeryActivities, local)
				break
			}
		}
	}

	return nil
}

// LoadDopsEvaluation allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (orthopedicSurgeryActivityL) LoadDopsEvaluation(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrthopedicSurgeryActivity interface{}, mods queries.Applicator) error {
	var slice []*OrthopedicSurgeryActivity
	var object *OrthopedicSurgeryActivity

	if singular {
		object = maybeOrthopedicSurgeryActivity.(*OrthopedicSurgeryActivity)
	} else {
		slice = *maybeOrthopedicSurgeryActivity.(*[]*OrthopedicSurgeryActivity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orthopedicSurgeryActivityR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orthopedicSurgeryActivityR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`dops_evaluations`),
		qm.WhereIn(`dops_evaluations.orthopedic_surgery_activity_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DopsEvaluation")
	}

	var resultSlice []*DopsEvaluation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DopsEvaluation")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for dops_evaluations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dops_evaluations")
	}

	if len(orthopedicSurgeryActivityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DopsEvaluation = foreign
		if foreign.R == nil {
			foreign.R = &dopsEvaluationR{}
		}
		foreign.R.OrthopedicSurgeryActivity = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ID, foreign.OrthopedicSurgeryActivityID) {
				local.R.DopsEvaluation = foreign
				if foreign.R == nil {
					foreign.R = &dopsEvaluationR{}
				}
				foreign.R.OrthopedicSurgeryActivity = local
				break
			}
		}
	}

	return nil
}

// LoadOrthopedicSurgeryLogbookEntry allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (orthopedicSurgeryActivityL) LoadOrthopedicSurgeryLogbookEntry(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrthopedicSurgeryActivity interface{}, mods queries.Applicator) error {
	var slice []*OrthopedicSurgeryActivity
	var object *OrthopedicSurgeryActivity

	if singular {
		object = maybeOrthopedicSurgeryActivity.(*OrthopedicSurgeryActivity)
	} else {
		slice = *maybeOrthopedicSurgeryActivity.(*[]*OrthopedicSurgeryActivity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orthopedicSurgeryActivityR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orthopedicSurgeryActivityR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`logbook_entries`),
		qm.WhereIn(`logbook_entries.orthopedic_surgery_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load LogbookEntry")
	}

	var resultSlice []*LogbookEntry
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice LogbookEntry")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for logbook_entries")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for logbook_entries")
	}

	if len(orthopedicSurgeryActivityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.OrthopedicSurgeryLogbookEntry = foreign
		if foreign.R == nil {
			foreign.R = &logbookEntryR{}
		}
		foreign.R.OrthopedicSurgery = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ID, foreign.OrthopedicSurgeryID) {
				local.R.OrthopedicSurgeryLogbookEntry = foreign
				if foreign.R == nil {
					foreign.R = &logbookEntryR{}
				}
				foreign.R.OrthopedicSurgery = local
				break
			}
		}
	}

	return nil
}

// LoadOrthopedicSurgeriesActivityReview allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (orthopedicSurgeryActivityL) LoadOrthopedicSurgeriesActivityReview(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrthopedicSurgeryActivity interface{}, mods queries.Applicator) error {
	var slice []*OrthopedicSurgeryActivity
	var object *OrthopedicSurgeryActivity

	if singular {
		object = maybeOrthopedicSurgeryActivity.(*OrthopedicSurgeryActivity)
	} else {
		slice = *maybeOrthopedicSurgeryActivity.(*[]*OrthopedicSurgeryActivity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orthopedicSurgeryActivityR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orthopedicSurgeryActivityR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`orthopedic_surgeries_activity_review`),
		qm.WhereIn(`orthopedic_surgeries_activity_review.orthopedic_surgery_activity_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load OrthopedicSurgeriesActivityReview")
	}

	var resultSlice []*OrthopedicSurgeriesActivityReview
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice OrthopedicSurgeriesActivityReview")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for orthopedic_surgeries_activity_review")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for orthopedic_surgeries_activity_review")
	}

	if len(orthopedicSurgeryActivityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.OrthopedicSurgeriesActivityReview = foreign
		if foreign.R == nil {
			foreign.R = &orthopedicSurgeriesActivityReviewR{}
		}
		foreign.R.OrthopedicSurgeryActivity = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.OrthopedicSurgeryActivityID {
				local.R.OrthopedicSurgeriesActivityReview = foreign
				if foreign.R == nil {
					foreign.R = &orthopedicSurgeriesActivityReviewR{}
				}
				foreign.R.OrthopedicSurgeryActivity = local
				break
			}
		}
	}

	return nil
}

// LoadOrthopedicSurgeryActivitiesSurgeries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (orthopedicSurgeryActivityL) LoadOrthopedicSurgeryActivitiesSurgeries(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrthopedicSurgeryActivity interface{}, mods queries.Applicator) error {
	var slice []*OrthopedicSurgeryActivity
	var object *OrthopedicSurgeryActivity

	if singular {
		object = maybeOrthopedicSurgeryActivity.(*OrthopedicSurgeryActivity)
	} else {
		slice = *maybeOrthopedicSurgeryActivity.(*[]*OrthopedicSurgeryActivity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orthopedicSurgeryActivityR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orthopedicSurgeryActivityR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`orthopedic_surgery_activities_surgeries`),
		qm.WhereIn(`orthopedic_surgery_activities_surgeries.orthopedic_surgery_activity_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load orthopedic_surgery_activities_surgeries")
	}

	var resultSlice []*OrthopedicSurgeryActivitiesSurgery
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice orthopedic_surgery_activities_surgeries")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on orthopedic_surgery_activities_surgeries")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for orthopedic_surgery_activities_surgeries")
	}

	if len(orthopedicSurgeryActivitiesSurgeryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OrthopedicSurgeryActivitiesSurgeries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &orthopedicSurgeryActivitiesSurgeryR{}
			}
			foreign.R.OrthopedicSurgeryActivity = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OrthopedicSurgeryActivityID {
				local.R.OrthopedicSurgeryActivitiesSurgeries = append(local.R.OrthopedicSurgeryActivitiesSurgeries, foreign)
				if foreign.R == nil {
					foreign.R = &orthopedicSurgeryActivitiesSurgeryR{}
				}
				foreign.R.OrthopedicSurgeryActivity = local
				break
			}
		}
	}

	return nil
}

// SetAssistant of the orthopedicSurgeryActivity to the related item.
// Sets o.R.Assistant to related.
// Adds o to related.R.AssistantOrthopedicSurgeryActivities.
func (o *OrthopedicSurgeryActivity) SetAssistant(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"orthopedic_surgery_activities\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"assistant_id"}),
		strmangle.WhereClause("\"", "\"", 2, orthopedicSurgeryActivityPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.AssistantID, related.ID)
	if o.R == nil {
		o.R = &orthopedicSurgeryActivityR{
			Assistant: related,
		}
	} else {
		o.R.Assistant = related
	}

	if related.R == nil {
		related.R = &userR{
			AssistantOrthopedicSurgeryActivities: OrthopedicSurgeryActivitySlice{o},
		}
	} else {
		related.R.AssistantOrthopedicSurgeryActivities = append(related.R.AssistantOrthopedicSurgeryActivities, o)
	}

	return nil
}

// RemoveAssistant relationship.
// Sets o.R.Assistant to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *OrthopedicSurgeryActivity) RemoveAssistant(ctx context.Context, exec boil.ContextExecutor, related *User) error {
	var err error

	queries.SetScanner(&o.AssistantID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("assistant_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Assistant = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.AssistantOrthopedicSurgeryActivities {
		if queries.Equal(o.AssistantID, ri.AssistantID) {
			continue
		}

		ln := len(related.R.AssistantOrthopedicSurgeryActivities)
		if ln > 1 && i < ln-1 {
			related.R.AssistantOrthopedicSurgeryActivities[i] = related.R.AssistantOrthopedicSurgeryActivities[ln-1]
		}
		related.R.AssistantOrthopedicSurgeryActivities = related.R.AssistantOrthopedicSurgeryActivities[:ln-1]
		break
	}
	return nil
}

// SetOperator of the orthopedicSurgeryActivity to the related item.
// Sets o.R.Operator to related.
// Adds o to related.R.OperatorOrthopedicSurgeryActivities.
func (o *OrthopedicSurgeryActivity) SetOperator(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"orthopedic_surgery_activities\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"operator_id"}),
		strmangle.WhereClause("\"", "\"", 2, orthopedicSurgeryActivityPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.OperatorID, related.ID)
	if o.R == nil {
		o.R = &orthopedicSurgeryActivityR{
			Operator: related,
		}
	} else {
		o.R.Operator = related
	}

	if related.R == nil {
		related.R = &userR{
			OperatorOrthopedicSurgeryActivities: OrthopedicSurgeryActivitySlice{o},
		}
	} else {
		related.R.OperatorOrthopedicSurgeryActivities = append(related.R.OperatorOrthopedicSurgeryActivities, o)
	}

	return nil
}

// RemoveOperator relationship.
// Sets o.R.Operator to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *OrthopedicSurgeryActivity) RemoveOperator(ctx context.Context, exec boil.ContextExecutor, related *User) error {
	var err error

	queries.SetScanner(&o.OperatorID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("operator_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Operator = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.OperatorOrthopedicSurgeryActivities {
		if queries.Equal(o.OperatorID, ri.OperatorID) {
			continue
		}

		ln := len(related.R.OperatorOrthopedicSurgeryActivities)
		if ln > 1 && i < ln-1 {
			related.R.OperatorOrthopedicSurgeryActivities[i] = related.R.OperatorOrthopedicSurgeryActivities[ln-1]
		}
		related.R.OperatorOrthopedicSurgeryActivities = related.R.OperatorOrthopedicSurgeryActivities[:ln-1]
		break
	}
	return nil
}

// SetPracticalActivityType of the orthopedicSurgeryActivity to the related item.
// Sets o.R.PracticalActivityType to related.
// Adds o to related.R.OrthopedicSurgeryActivities.
func (o *OrthopedicSurgeryActivity) SetPracticalActivityType(ctx context.Context, exec boil.ContextExecutor, insert bool, related *PracticalActivityType) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"orthopedic_surgery_activities\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"practical_activity_type_id"}),
		strmangle.WhereClause("\"", "\"", 2, orthopedicSurgeryActivityPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.PracticalActivityTypeID = related.ID
	if o.R == nil {
		o.R = &orthopedicSurgeryActivityR{
			PracticalActivityType: related,
		}
	} else {
		o.R.PracticalActivityType = related
	}

	if related.R == nil {
		related.R = &practicalActivityTypeR{
			OrthopedicSurgeryActivities: OrthopedicSurgeryActivitySlice{o},
		}
	} else {
		related.R.OrthopedicSurgeryActivities = append(related.R.OrthopedicSurgeryActivities, o)
	}

	return nil
}

// SetResident of the orthopedicSurgeryActivity to the related item.
// Sets o.R.Resident to related.
// Adds o to related.R.ResidentOrthopedicSurgeryActivities.
func (o *OrthopedicSurgeryActivity) SetResident(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"orthopedic_surgery_activities\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"resident_id"}),
		strmangle.WhereClause("\"", "\"", 2, orthopedicSurgeryActivityPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ResidentID = related.ID
	if o.R == nil {
		o.R = &orthopedicSurgeryActivityR{
			Resident: related,
		}
	} else {
		o.R.Resident = related
	}

	if related.R == nil {
		related.R = &userR{
			ResidentOrthopedicSurgeryActivities: OrthopedicSurgeryActivitySlice{o},
		}
	} else {
		related.R.ResidentOrthopedicSurgeryActivities = append(related.R.ResidentOrthopedicSurgeryActivities, o)
	}

	return nil
}

// SetSupervisor of the orthopedicSurgeryActivity to the related item.
// Sets o.R.Supervisor to related.
// Adds o to related.R.SupervisorOrthopedicSurgeryActivities.
func (o *OrthopedicSurgeryActivity) SetSupervisor(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"orthopedic_surgery_activities\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"supervisor_id"}),
		strmangle.WhereClause("\"", "\"", 2, orthopedicSurgeryActivityPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.SupervisorID, related.ID)
	if o.R == nil {
		o.R = &orthopedicSurgeryActivityR{
			Supervisor: related,
		}
	} else {
		o.R.Supervisor = related
	}

	if related.R == nil {
		related.R = &userR{
			SupervisorOrthopedicSurgeryActivities: OrthopedicSurgeryActivitySlice{o},
		}
	} else {
		related.R.SupervisorOrthopedicSurgeryActivities = append(related.R.SupervisorOrthopedicSurgeryActivities, o)
	}

	return nil
}

// RemoveSupervisor relationship.
// Sets o.R.Supervisor to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *OrthopedicSurgeryActivity) RemoveSupervisor(ctx context.Context, exec boil.ContextExecutor, related *User) error {
	var err error

	queries.SetScanner(&o.SupervisorID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("supervisor_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Supervisor = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.SupervisorOrthopedicSurgeryActivities {
		if queries.Equal(o.SupervisorID, ri.SupervisorID) {
			continue
		}

		ln := len(related.R.SupervisorOrthopedicSurgeryActivities)
		if ln > 1 && i < ln-1 {
			related.R.SupervisorOrthopedicSurgeryActivities[i] = related.R.SupervisorOrthopedicSurgeryActivities[ln-1]
		}
		related.R.SupervisorOrthopedicSurgeryActivities = related.R.SupervisorOrthopedicSurgeryActivities[:ln-1]
		break
	}
	return nil
}

// SetDopsEvaluation of the orthopedicSurgeryActivity to the related item.
// Sets o.R.DopsEvaluation to related.
// Adds o to related.R.OrthopedicSurgeryActivity.
func (o *OrthopedicSurgeryActivity) SetDopsEvaluation(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DopsEvaluation) error {
	var err error

	if insert {
		queries.Assign(&related.OrthopedicSurgeryActivityID, o.ID)

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"dops_evaluations\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"orthopedic_surgery_activity_id"}),
			strmangle.WhereClause("\"", "\"", 2, dopsEvaluationPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.OrthopedicSurgeryActivityID, o.ID)
	}

	if o.R == nil {
		o.R = &orthopedicSurgeryActivityR{
			DopsEvaluation: related,
		}
	} else {
		o.R.DopsEvaluation = related
	}

	if related.R == nil {
		related.R = &dopsEvaluationR{
			OrthopedicSurgeryActivity: o,
		}
	} else {
		related.R.OrthopedicSurgeryActivity = o
	}
	return nil
}

// RemoveDopsEvaluation relationship.
// Sets o.R.DopsEvaluation to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *OrthopedicSurgeryActivity) RemoveDopsEvaluation(ctx context.Context, exec boil.ContextExecutor, related *DopsEvaluation) error {
	var err error

	queries.SetScanner(&related.OrthopedicSurgeryActivityID, nil)
	if _, err = related.Update(ctx, exec, boil.Whitelist("orthopedic_surgery_activity_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DopsEvaluation = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	related.R.OrthopedicSurgeryActivity = nil
	return nil
}

// SetOrthopedicSurgeryLogbookEntry of the orthopedicSurgeryActivity to the related item.
// Sets o.R.OrthopedicSurgeryLogbookEntry to related.
// Adds o to related.R.OrthopedicSurgery.
func (o *OrthopedicSurgeryActivity) SetOrthopedicSurgeryLogbookEntry(ctx context.Context, exec boil.ContextExecutor, insert bool, related *LogbookEntry) error {
	var err error

	if insert {
		queries.Assign(&related.OrthopedicSurgeryID, o.ID)

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"logbook_entries\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"orthopedic_surgery_id"}),
			strmangle.WhereClause("\"", "\"", 2, logbookEntryPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.OrthopedicSurgeryID, o.ID)
	}

	if o.R == nil {
		o.R = &orthopedicSurgeryActivityR{
			OrthopedicSurgeryLogbookEntry: related,
		}
	} else {
		o.R.OrthopedicSurgeryLogbookEntry = related
	}

	if related.R == nil {
		related.R = &logbookEntryR{
			OrthopedicSurgery: o,
		}
	} else {
		related.R.OrthopedicSurgery = o
	}
	return nil
}

// RemoveOrthopedicSurgeryLogbookEntry relationship.
// Sets o.R.OrthopedicSurgeryLogbookEntry to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *OrthopedicSurgeryActivity) RemoveOrthopedicSurgeryLogbookEntry(ctx context.Context, exec boil.ContextExecutor, related *LogbookEntry) error {
	var err error

	queries.SetScanner(&related.OrthopedicSurgeryID, nil)
	if _, err = related.Update(ctx, exec, boil.Whitelist("orthopedic_surgery_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.OrthopedicSurgeryLogbookEntry = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	related.R.OrthopedicSurgery = nil
	return nil
}

// SetOrthopedicSurgeriesActivityReview of the orthopedicSurgeryActivity to the related item.
// Sets o.R.OrthopedicSurgeriesActivityReview to related.
// Adds o to related.R.OrthopedicSurgeryActivity.
func (o *OrthopedicSurgeryActivity) SetOrthopedicSurgeriesActivityReview(ctx context.Context, exec boil.ContextExecutor, insert bool, related *OrthopedicSurgeriesActivityReview) error {
	var err error

	if insert {
		related.OrthopedicSurgeryActivityID = o.ID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"orthopedic_surgeries_activity_review\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"orthopedic_surgery_activity_id"}),
			strmangle.WhereClause("\"", "\"", 2, orthopedicSurgeriesActivityReviewPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.OrthopedicSurgeryActivityID = o.ID

	}

	if o.R == nil {
		o.R = &orthopedicSurgeryActivityR{
			OrthopedicSurgeriesActivityReview: related,
		}
	} else {
		o.R.OrthopedicSurgeriesActivityReview = related
	}

	if related.R == nil {
		related.R = &orthopedicSurgeriesActivityReviewR{
			OrthopedicSurgeryActivity: o,
		}
	} else {
		related.R.OrthopedicSurgeryActivity = o
	}
	return nil
}

// AddOrthopedicSurgeryActivitiesSurgeries adds the given related objects to the existing relationships
// of the orthopedic_surgery_activity, optionally inserting them as new records.
// Appends related to o.R.OrthopedicSurgeryActivitiesSurgeries.
// Sets related.R.OrthopedicSurgeryActivity appropriately.
func (o *OrthopedicSurgeryActivity) AddOrthopedicSurgeryActivitiesSurgeries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*OrthopedicSurgeryActivitiesSurgery) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OrthopedicSurgeryActivityID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"orthopedic_surgery_activities_surgeries\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"orthopedic_surgery_activity_id"}),
				strmangle.WhereClause("\"", "\"", 2, orthopedicSurgeryActivitiesSurgeryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OrthopedicSurgeryActivityID = o.ID
		}
	}

	if o.R == nil {
		o.R = &orthopedicSurgeryActivityR{
			OrthopedicSurgeryActivitiesSurgeries: related,
		}
	} else {
		o.R.OrthopedicSurgeryActivitiesSurgeries = append(o.R.OrthopedicSurgeryActivitiesSurgeries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &orthopedicSurgeryActivitiesSurgeryR{
				OrthopedicSurgeryActivity: o,
			}
		} else {
			rel.R.OrthopedicSurgeryActivity = o
		}
	}
	return nil
}

// OrthopedicSurgeryActivities retrieves all the records using an executor.
func OrthopedicSurgeryActivities(mods ...qm.QueryMod) orthopedicSurgeryActivityQuery {
	mods = append(mods, qm.From("\"orthopedic_surgery_activities\""))
	return orthopedicSurgeryActivityQuery{NewQuery(mods...)}
}

// FindOrthopedicSurgeryActivity retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindOrthopedicSurgeryActivity(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*OrthopedicSurgeryActivity, error) {
	orthopedicSurgeryActivityObj := &OrthopedicSurgeryActivity{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"orthopedic_surgery_activities\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, orthopedicSurgeryActivityObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from orthopedic_surgery_activities")
	}

	if err = orthopedicSurgeryActivityObj.doAfterSelectHooks(ctx, exec); err != nil {
		return orthopedicSurgeryActivityObj, err
	}

	return orthopedicSurgeryActivityObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *OrthopedicSurgeryActivity) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no orthopedic_surgery_activities provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(orthopedicSurgeryActivityColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	orthopedicSurgeryActivityInsertCacheMut.RLock()
	cache, cached := orthopedicSurgeryActivityInsertCache[key]
	orthopedicSurgeryActivityInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			orthopedicSurgeryActivityAllColumns,
			orthopedicSurgeryActivityColumnsWithDefault,
			orthopedicSurgeryActivityColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(orthopedicSurgeryActivityType, orthopedicSurgeryActivityMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(orthopedicSurgeryActivityType, orthopedicSurgeryActivityMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"orthopedic_surgery_activities\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"orthopedic_surgery_activities\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into orthopedic_surgery_activities")
	}

	if !cached {
		orthopedicSurgeryActivityInsertCacheMut.Lock()
		orthopedicSurgeryActivityInsertCache[key] = cache
		orthopedicSurgeryActivityInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the OrthopedicSurgeryActivity.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *OrthopedicSurgeryActivity) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	orthopedicSurgeryActivityUpdateCacheMut.RLock()
	cache, cached := orthopedicSurgeryActivityUpdateCache[key]
	orthopedicSurgeryActivityUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			orthopedicSurgeryActivityAllColumns,
			orthopedicSurgeryActivityPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update orthopedic_surgery_activities, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"orthopedic_surgery_activities\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, orthopedicSurgeryActivityPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(orthopedicSurgeryActivityType, orthopedicSurgeryActivityMapping, append(wl, orthopedicSurgeryActivityPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update orthopedic_surgery_activities row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for orthopedic_surgery_activities")
	}

	if !cached {
		orthopedicSurgeryActivityUpdateCacheMut.Lock()
		orthopedicSurgeryActivityUpdateCache[key] = cache
		orthopedicSurgeryActivityUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q orthopedicSurgeryActivityQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for orthopedic_surgery_activities")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for orthopedic_surgery_activities")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o OrthopedicSurgeryActivitySlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), orthopedicSurgeryActivityPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"orthopedic_surgery_activities\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, orthopedicSurgeryActivityPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in orthopedicSurgeryActivity slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all orthopedicSurgeryActivity")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *OrthopedicSurgeryActivity) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no orthopedic_surgery_activities provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(orthopedicSurgeryActivityColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	orthopedicSurgeryActivityUpsertCacheMut.RLock()
	cache, cached := orthopedicSurgeryActivityUpsertCache[key]
	orthopedicSurgeryActivityUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			orthopedicSurgeryActivityAllColumns,
			orthopedicSurgeryActivityColumnsWithDefault,
			orthopedicSurgeryActivityColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			orthopedicSurgeryActivityAllColumns,
			orthopedicSurgeryActivityPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert orthopedic_surgery_activities, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(orthopedicSurgeryActivityPrimaryKeyColumns))
			copy(conflict, orthopedicSurgeryActivityPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"orthopedic_surgery_activities\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(orthopedicSurgeryActivityType, orthopedicSurgeryActivityMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(orthopedicSurgeryActivityType, orthopedicSurgeryActivityMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert orthopedic_surgery_activities")
	}

	if !cached {
		orthopedicSurgeryActivityUpsertCacheMut.Lock()
		orthopedicSurgeryActivityUpsertCache[key] = cache
		orthopedicSurgeryActivityUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single OrthopedicSurgeryActivity record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *OrthopedicSurgeryActivity) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no OrthopedicSurgeryActivity provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), orthopedicSurgeryActivityPrimaryKeyMapping)
	sql := "DELETE FROM \"orthopedic_surgery_activities\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from orthopedic_surgery_activities")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for orthopedic_surgery_activities")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q orthopedicSurgeryActivityQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no orthopedicSurgeryActivityQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from orthopedic_surgery_activities")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for orthopedic_surgery_activities")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o OrthopedicSurgeryActivitySlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(orthopedicSurgeryActivityBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), orthopedicSurgeryActivityPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"orthopedic_surgery_activities\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, orthopedicSurgeryActivityPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from orthopedicSurgeryActivity slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for orthopedic_surgery_activities")
	}

	if len(orthopedicSurgeryActivityAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *OrthopedicSurgeryActivity) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindOrthopedicSurgeryActivity(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *OrthopedicSurgeryActivitySlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := OrthopedicSurgeryActivitySlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), orthopedicSurgeryActivityPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"orthopedic_surgery_activities\".* FROM \"orthopedic_surgery_activities\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, orthopedicSurgeryActivityPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in OrthopedicSurgeryActivitySlice")
	}

	*o = slice

	return nil
}

// OrthopedicSurgeryActivityExists checks if the OrthopedicSurgeryActivity row exists.
func OrthopedicSurgeryActivityExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"orthopedic_surgery_activities\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if orthopedic_surgery_activities exists")
	}

	return exists, nil
}
