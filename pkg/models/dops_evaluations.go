// Code generated by SQLBoiler 4.8.3 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// DopsEvaluation is an object representing the database table.
type DopsEvaluation struct {
	ID                          string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	OrthopedicSurgeryActivityID null.String `boil:"orthopedic_surgery_activity_id" json:"orthopedic_surgery_activity_id,omitempty" toml:"orthopedic_surgery_activity_id" yaml:"orthopedic_surgery_activity_id,omitempty"`
	ResidentID                  string      `boil:"resident_id" json:"resident_id" toml:"resident_id" yaml:"resident_id"`
	SupervisorID                string      `boil:"supervisor_id" json:"supervisor_id" toml:"supervisor_id" yaml:"supervisor_id"`
	OccurredAt                  time.Time   `boil:"occurred_at" json:"occurred_at" toml:"occurred_at" yaml:"occurred_at"`
	CaseNotes                   string      `boil:"case_notes" json:"case_notes" toml:"case_notes" yaml:"case_notes"`
	PatientAge                  int         `boil:"patient_age" json:"patient_age" toml:"patient_age" yaml:"patient_age"`
	PatientGender               string      `boil:"patient_gender" json:"patient_gender" toml:"patient_gender" yaml:"patient_gender"`
	Difficulty                  string      `boil:"difficulty" json:"difficulty" toml:"difficulty" yaml:"difficulty"`
	DepartmentID                null.String `boil:"department_id" json:"department_id,omitempty" toml:"department_id" yaml:"department_id,omitempty"`
	Annotations                 types.JSON  `boil:"annotations" json:"annotations" toml:"annotations" yaml:"annotations"`
	IsEvaluated                 bool        `boil:"is_evaluated" json:"is_evaluated" toml:"is_evaluated" yaml:"is_evaluated"`
	CreatedAt                   time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	InProgress                  bool        `boil:"in_progress" json:"in_progress" toml:"in_progress" yaml:"in_progress"`
	ActiveStep                  int         `boil:"active_step" json:"active_step" toml:"active_step" yaml:"active_step"`
	CompletedStep               int         `boil:"completed_step" json:"completed_step" toml:"completed_step" yaml:"completed_step"`

	R *dopsEvaluationR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dopsEvaluationL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DopsEvaluationColumns = struct {
	ID                          string
	OrthopedicSurgeryActivityID string
	ResidentID                  string
	SupervisorID                string
	OccurredAt                  string
	CaseNotes                   string
	PatientAge                  string
	PatientGender               string
	Difficulty                  string
	DepartmentID                string
	Annotations                 string
	IsEvaluated                 string
	CreatedAt                   string
	InProgress                  string
	ActiveStep                  string
	CompletedStep               string
}{
	ID:                          "id",
	OrthopedicSurgeryActivityID: "orthopedic_surgery_activity_id",
	ResidentID:                  "resident_id",
	SupervisorID:                "supervisor_id",
	OccurredAt:                  "occurred_at",
	CaseNotes:                   "case_notes",
	PatientAge:                  "patient_age",
	PatientGender:               "patient_gender",
	Difficulty:                  "difficulty",
	DepartmentID:                "department_id",
	Annotations:                 "annotations",
	IsEvaluated:                 "is_evaluated",
	CreatedAt:                   "created_at",
	InProgress:                  "in_progress",
	ActiveStep:                  "active_step",
	CompletedStep:               "completed_step",
}

var DopsEvaluationTableColumns = struct {
	ID                          string
	OrthopedicSurgeryActivityID string
	ResidentID                  string
	SupervisorID                string
	OccurredAt                  string
	CaseNotes                   string
	PatientAge                  string
	PatientGender               string
	Difficulty                  string
	DepartmentID                string
	Annotations                 string
	IsEvaluated                 string
	CreatedAt                   string
	InProgress                  string
	ActiveStep                  string
	CompletedStep               string
}{
	ID:                          "dops_evaluations.id",
	OrthopedicSurgeryActivityID: "dops_evaluations.orthopedic_surgery_activity_id",
	ResidentID:                  "dops_evaluations.resident_id",
	SupervisorID:                "dops_evaluations.supervisor_id",
	OccurredAt:                  "dops_evaluations.occurred_at",
	CaseNotes:                   "dops_evaluations.case_notes",
	PatientAge:                  "dops_evaluations.patient_age",
	PatientGender:               "dops_evaluations.patient_gender",
	Difficulty:                  "dops_evaluations.difficulty",
	DepartmentID:                "dops_evaluations.department_id",
	Annotations:                 "dops_evaluations.annotations",
	IsEvaluated:                 "dops_evaluations.is_evaluated",
	CreatedAt:                   "dops_evaluations.created_at",
	InProgress:                  "dops_evaluations.in_progress",
	ActiveStep:                  "dops_evaluations.active_step",
	CompletedStep:               "dops_evaluations.completed_step",
}

// Generated where

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpertypes_JSON struct{ field string }

func (w whereHelpertypes_JSON) EQ(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertypes_JSON) NEQ(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertypes_JSON) LT(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_JSON) LTE(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_JSON) GT(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_JSON) GTE(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

var DopsEvaluationWhere = struct {
	ID                          whereHelperstring
	OrthopedicSurgeryActivityID whereHelpernull_String
	ResidentID                  whereHelperstring
	SupervisorID                whereHelperstring
	OccurredAt                  whereHelpertime_Time
	CaseNotes                   whereHelperstring
	PatientAge                  whereHelperint
	PatientGender               whereHelperstring
	Difficulty                  whereHelperstring
	DepartmentID                whereHelpernull_String
	Annotations                 whereHelpertypes_JSON
	IsEvaluated                 whereHelperbool
	CreatedAt                   whereHelpertime_Time
	InProgress                  whereHelperbool
	ActiveStep                  whereHelperint
	CompletedStep               whereHelperint
}{
	ID:                          whereHelperstring{field: "\"dops_evaluations\".\"id\""},
	OrthopedicSurgeryActivityID: whereHelpernull_String{field: "\"dops_evaluations\".\"orthopedic_surgery_activity_id\""},
	ResidentID:                  whereHelperstring{field: "\"dops_evaluations\".\"resident_id\""},
	SupervisorID:                whereHelperstring{field: "\"dops_evaluations\".\"supervisor_id\""},
	OccurredAt:                  whereHelpertime_Time{field: "\"dops_evaluations\".\"occurred_at\""},
	CaseNotes:                   whereHelperstring{field: "\"dops_evaluations\".\"case_notes\""},
	PatientAge:                  whereHelperint{field: "\"dops_evaluations\".\"patient_age\""},
	PatientGender:               whereHelperstring{field: "\"dops_evaluations\".\"patient_gender\""},
	Difficulty:                  whereHelperstring{field: "\"dops_evaluations\".\"difficulty\""},
	DepartmentID:                whereHelpernull_String{field: "\"dops_evaluations\".\"department_id\""},
	Annotations:                 whereHelpertypes_JSON{field: "\"dops_evaluations\".\"annotations\""},
	IsEvaluated:                 whereHelperbool{field: "\"dops_evaluations\".\"is_evaluated\""},
	CreatedAt:                   whereHelpertime_Time{field: "\"dops_evaluations\".\"created_at\""},
	InProgress:                  whereHelperbool{field: "\"dops_evaluations\".\"in_progress\""},
	ActiveStep:                  whereHelperint{field: "\"dops_evaluations\".\"active_step\""},
	CompletedStep:               whereHelperint{field: "\"dops_evaluations\".\"completed_step\""},
}

// DopsEvaluationRels is where relationship names are stored.
var DopsEvaluationRels = struct {
	Department                string
	OrthopedicSurgeryActivity string
	Resident                  string
	Supervisor                string
	DopAssessment             string
	DopsEvaluationsSurgeries  string
}{
	Department:                "Department",
	OrthopedicSurgeryActivity: "OrthopedicSurgeryActivity",
	Resident:                  "Resident",
	Supervisor:                "Supervisor",
	DopAssessment:             "DopAssessment",
	DopsEvaluationsSurgeries:  "DopsEvaluationsSurgeries",
}

// dopsEvaluationR is where relationships are stored.
type dopsEvaluationR struct {
	Department                *OrganizationalUnit         `boil:"Department" json:"Department" toml:"Department" yaml:"Department"`
	OrthopedicSurgeryActivity *OrthopedicSurgeryActivity  `boil:"OrthopedicSurgeryActivity" json:"OrthopedicSurgeryActivity" toml:"OrthopedicSurgeryActivity" yaml:"OrthopedicSurgeryActivity"`
	Resident                  *User                       `boil:"Resident" json:"Resident" toml:"Resident" yaml:"Resident"`
	Supervisor                *User                       `boil:"Supervisor" json:"Supervisor" toml:"Supervisor" yaml:"Supervisor"`
	DopAssessment             *Assessment                 `boil:"DopAssessment" json:"DopAssessment" toml:"DopAssessment" yaml:"DopAssessment"`
	DopsEvaluationsSurgeries  DopsEvaluationsSurgerySlice `boil:"DopsEvaluationsSurgeries" json:"DopsEvaluationsSurgeries" toml:"DopsEvaluationsSurgeries" yaml:"DopsEvaluationsSurgeries"`
}

// NewStruct creates a new relationship struct
func (*dopsEvaluationR) NewStruct() *dopsEvaluationR {
	return &dopsEvaluationR{}
}

// dopsEvaluationL is where Load methods for each relationship are stored.
type dopsEvaluationL struct{}

var (
	dopsEvaluationAllColumns            = []string{"id", "orthopedic_surgery_activity_id", "resident_id", "supervisor_id", "occurred_at", "case_notes", "patient_age", "patient_gender", "difficulty", "department_id", "annotations", "is_evaluated", "created_at", "in_progress", "active_step", "completed_step"}
	dopsEvaluationColumnsWithoutDefault = []string{"orthopedic_surgery_activity_id", "resident_id", "supervisor_id", "occurred_at", "case_notes", "patient_age", "patient_gender", "department_id"}
	dopsEvaluationColumnsWithDefault    = []string{"id", "difficulty", "annotations", "is_evaluated", "created_at", "in_progress", "active_step", "completed_step"}
	dopsEvaluationPrimaryKeyColumns     = []string{"id"}
)

type (
	// DopsEvaluationSlice is an alias for a slice of pointers to DopsEvaluation.
	// This should almost always be used instead of []DopsEvaluation.
	DopsEvaluationSlice []*DopsEvaluation
	// DopsEvaluationHook is the signature for custom DopsEvaluation hook methods
	DopsEvaluationHook func(context.Context, boil.ContextExecutor, *DopsEvaluation) error

	dopsEvaluationQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dopsEvaluationType                 = reflect.TypeOf(&DopsEvaluation{})
	dopsEvaluationMapping              = queries.MakeStructMapping(dopsEvaluationType)
	dopsEvaluationPrimaryKeyMapping, _ = queries.BindMapping(dopsEvaluationType, dopsEvaluationMapping, dopsEvaluationPrimaryKeyColumns)
	dopsEvaluationInsertCacheMut       sync.RWMutex
	dopsEvaluationInsertCache          = make(map[string]insertCache)
	dopsEvaluationUpdateCacheMut       sync.RWMutex
	dopsEvaluationUpdateCache          = make(map[string]updateCache)
	dopsEvaluationUpsertCacheMut       sync.RWMutex
	dopsEvaluationUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var dopsEvaluationBeforeInsertHooks []DopsEvaluationHook
var dopsEvaluationBeforeUpdateHooks []DopsEvaluationHook
var dopsEvaluationBeforeDeleteHooks []DopsEvaluationHook
var dopsEvaluationBeforeUpsertHooks []DopsEvaluationHook

var dopsEvaluationAfterInsertHooks []DopsEvaluationHook
var dopsEvaluationAfterSelectHooks []DopsEvaluationHook
var dopsEvaluationAfterUpdateHooks []DopsEvaluationHook
var dopsEvaluationAfterDeleteHooks []DopsEvaluationHook
var dopsEvaluationAfterUpsertHooks []DopsEvaluationHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *DopsEvaluation) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dopsEvaluationBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *DopsEvaluation) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dopsEvaluationBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *DopsEvaluation) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dopsEvaluationBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *DopsEvaluation) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dopsEvaluationBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *DopsEvaluation) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dopsEvaluationAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *DopsEvaluation) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dopsEvaluationAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *DopsEvaluation) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dopsEvaluationAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *DopsEvaluation) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dopsEvaluationAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *DopsEvaluation) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dopsEvaluationAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddDopsEvaluationHook registers your hook function for all future operations.
func AddDopsEvaluationHook(hookPoint boil.HookPoint, dopsEvaluationHook DopsEvaluationHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		dopsEvaluationBeforeInsertHooks = append(dopsEvaluationBeforeInsertHooks, dopsEvaluationHook)
	case boil.BeforeUpdateHook:
		dopsEvaluationBeforeUpdateHooks = append(dopsEvaluationBeforeUpdateHooks, dopsEvaluationHook)
	case boil.BeforeDeleteHook:
		dopsEvaluationBeforeDeleteHooks = append(dopsEvaluationBeforeDeleteHooks, dopsEvaluationHook)
	case boil.BeforeUpsertHook:
		dopsEvaluationBeforeUpsertHooks = append(dopsEvaluationBeforeUpsertHooks, dopsEvaluationHook)
	case boil.AfterInsertHook:
		dopsEvaluationAfterInsertHooks = append(dopsEvaluationAfterInsertHooks, dopsEvaluationHook)
	case boil.AfterSelectHook:
		dopsEvaluationAfterSelectHooks = append(dopsEvaluationAfterSelectHooks, dopsEvaluationHook)
	case boil.AfterUpdateHook:
		dopsEvaluationAfterUpdateHooks = append(dopsEvaluationAfterUpdateHooks, dopsEvaluationHook)
	case boil.AfterDeleteHook:
		dopsEvaluationAfterDeleteHooks = append(dopsEvaluationAfterDeleteHooks, dopsEvaluationHook)
	case boil.AfterUpsertHook:
		dopsEvaluationAfterUpsertHooks = append(dopsEvaluationAfterUpsertHooks, dopsEvaluationHook)
	}
}

// One returns a single dopsEvaluation record from the query.
func (q dopsEvaluationQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DopsEvaluation, error) {
	o := &DopsEvaluation{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for dops_evaluations")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all DopsEvaluation records from the query.
func (q dopsEvaluationQuery) All(ctx context.Context, exec boil.ContextExecutor) (DopsEvaluationSlice, error) {
	var o []*DopsEvaluation

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to DopsEvaluation slice")
	}

	if len(dopsEvaluationAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all DopsEvaluation records in the query.
func (q dopsEvaluationQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count dops_evaluations rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dopsEvaluationQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if dops_evaluations exists")
	}

	return count > 0, nil
}

// Department pointed to by the foreign key.
func (o *DopsEvaluation) Department(mods ...qm.QueryMod) organizationalUnitQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.DepartmentID),
	}

	queryMods = append(queryMods, mods...)

	query := OrganizationalUnits(queryMods...)
	queries.SetFrom(query.Query, "\"organizational_units\"")

	return query
}

// OrthopedicSurgeryActivity pointed to by the foreign key.
func (o *DopsEvaluation) OrthopedicSurgeryActivity(mods ...qm.QueryMod) orthopedicSurgeryActivityQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.OrthopedicSurgeryActivityID),
	}

	queryMods = append(queryMods, mods...)

	query := OrthopedicSurgeryActivities(queryMods...)
	queries.SetFrom(query.Query, "\"orthopedic_surgery_activities\"")

	return query
}

// Resident pointed to by the foreign key.
func (o *DopsEvaluation) Resident(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ResidentID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	return query
}

// Supervisor pointed to by the foreign key.
func (o *DopsEvaluation) Supervisor(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.SupervisorID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	return query
}

// DopAssessment pointed to by the foreign key.
func (o *DopsEvaluation) DopAssessment(mods ...qm.QueryMod) assessmentQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"dops_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	query := Assessments(queryMods...)
	queries.SetFrom(query.Query, "\"assessments\"")

	return query
}

// DopsEvaluationsSurgeries retrieves all the dops_evaluations_surgery's DopsEvaluationsSurgeries with an executor.
func (o *DopsEvaluation) DopsEvaluationsSurgeries(mods ...qm.QueryMod) dopsEvaluationsSurgeryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"dops_evaluations_surgeries\".\"dops_evaluation_id\"=?", o.ID),
	)

	query := DopsEvaluationsSurgeries(queryMods...)
	queries.SetFrom(query.Query, "\"dops_evaluations_surgeries\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"dops_evaluations_surgeries\".*"})
	}

	return query
}

// LoadDepartment allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dopsEvaluationL) LoadDepartment(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDopsEvaluation interface{}, mods queries.Applicator) error {
	var slice []*DopsEvaluation
	var object *DopsEvaluation

	if singular {
		object = maybeDopsEvaluation.(*DopsEvaluation)
	} else {
		slice = *maybeDopsEvaluation.(*[]*DopsEvaluation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dopsEvaluationR{}
		}
		if !queries.IsNil(object.DepartmentID) {
			args = append(args, object.DepartmentID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dopsEvaluationR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DepartmentID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DepartmentID) {
				args = append(args, obj.DepartmentID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`organizational_units`),
		qm.WhereIn(`organizational_units.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load OrganizationalUnit")
	}

	var resultSlice []*OrganizationalUnit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice OrganizationalUnit")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for organizational_units")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for organizational_units")
	}

	if len(dopsEvaluationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Department = foreign
		if foreign.R == nil {
			foreign.R = &organizationalUnitR{}
		}
		foreign.R.DepartmentDopsEvaluations = append(foreign.R.DepartmentDopsEvaluations, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DepartmentID, foreign.ID) {
				local.R.Department = foreign
				if foreign.R == nil {
					foreign.R = &organizationalUnitR{}
				}
				foreign.R.DepartmentDopsEvaluations = append(foreign.R.DepartmentDopsEvaluations, local)
				break
			}
		}
	}

	return nil
}

// LoadOrthopedicSurgeryActivity allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dopsEvaluationL) LoadOrthopedicSurgeryActivity(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDopsEvaluation interface{}, mods queries.Applicator) error {
	var slice []*DopsEvaluation
	var object *DopsEvaluation

	if singular {
		object = maybeDopsEvaluation.(*DopsEvaluation)
	} else {
		slice = *maybeDopsEvaluation.(*[]*DopsEvaluation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dopsEvaluationR{}
		}
		if !queries.IsNil(object.OrthopedicSurgeryActivityID) {
			args = append(args, object.OrthopedicSurgeryActivityID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dopsEvaluationR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OrthopedicSurgeryActivityID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.OrthopedicSurgeryActivityID) {
				args = append(args, obj.OrthopedicSurgeryActivityID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`orthopedic_surgery_activities`),
		qm.WhereIn(`orthopedic_surgery_activities.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load OrthopedicSurgeryActivity")
	}

	var resultSlice []*OrthopedicSurgeryActivity
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice OrthopedicSurgeryActivity")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for orthopedic_surgery_activities")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for orthopedic_surgery_activities")
	}

	if len(dopsEvaluationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.OrthopedicSurgeryActivity = foreign
		if foreign.R == nil {
			foreign.R = &orthopedicSurgeryActivityR{}
		}
		foreign.R.DopsEvaluation = object
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.OrthopedicSurgeryActivityID, foreign.ID) {
				local.R.OrthopedicSurgeryActivity = foreign
				if foreign.R == nil {
					foreign.R = &orthopedicSurgeryActivityR{}
				}
				foreign.R.DopsEvaluation = local
				break
			}
		}
	}

	return nil
}

// LoadResident allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dopsEvaluationL) LoadResident(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDopsEvaluation interface{}, mods queries.Applicator) error {
	var slice []*DopsEvaluation
	var object *DopsEvaluation

	if singular {
		object = maybeDopsEvaluation.(*DopsEvaluation)
	} else {
		slice = *maybeDopsEvaluation.(*[]*DopsEvaluation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dopsEvaluationR{}
		}
		args = append(args, object.ResidentID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dopsEvaluationR{}
			}

			for _, a := range args {
				if a == obj.ResidentID {
					continue Outer
				}
			}

			args = append(args, obj.ResidentID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(dopsEvaluationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Resident = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.ResidentDopsEvaluations = append(foreign.R.ResidentDopsEvaluations, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ResidentID == foreign.ID {
				local.R.Resident = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.ResidentDopsEvaluations = append(foreign.R.ResidentDopsEvaluations, local)
				break
			}
		}
	}

	return nil
}

// LoadSupervisor allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dopsEvaluationL) LoadSupervisor(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDopsEvaluation interface{}, mods queries.Applicator) error {
	var slice []*DopsEvaluation
	var object *DopsEvaluation

	if singular {
		object = maybeDopsEvaluation.(*DopsEvaluation)
	} else {
		slice = *maybeDopsEvaluation.(*[]*DopsEvaluation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dopsEvaluationR{}
		}
		args = append(args, object.SupervisorID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dopsEvaluationR{}
			}

			for _, a := range args {
				if a == obj.SupervisorID {
					continue Outer
				}
			}

			args = append(args, obj.SupervisorID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(dopsEvaluationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Supervisor = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.SupervisorDopsEvaluations = append(foreign.R.SupervisorDopsEvaluations, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.SupervisorID == foreign.ID {
				local.R.Supervisor = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.SupervisorDopsEvaluations = append(foreign.R.SupervisorDopsEvaluations, local)
				break
			}
		}
	}

	return nil
}

// LoadDopAssessment allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (dopsEvaluationL) LoadDopAssessment(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDopsEvaluation interface{}, mods queries.Applicator) error {
	var slice []*DopsEvaluation
	var object *DopsEvaluation

	if singular {
		object = maybeDopsEvaluation.(*DopsEvaluation)
	} else {
		slice = *maybeDopsEvaluation.(*[]*DopsEvaluation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dopsEvaluationR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dopsEvaluationR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`assessments`),
		qm.WhereIn(`assessments.dops_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Assessment")
	}

	var resultSlice []*Assessment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Assessment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for assessments")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for assessments")
	}

	if len(dopsEvaluationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DopAssessment = foreign
		if foreign.R == nil {
			foreign.R = &assessmentR{}
		}
		foreign.R.Dop = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ID, foreign.DopsID) {
				local.R.DopAssessment = foreign
				if foreign.R == nil {
					foreign.R = &assessmentR{}
				}
				foreign.R.Dop = local
				break
			}
		}
	}

	return nil
}

// LoadDopsEvaluationsSurgeries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dopsEvaluationL) LoadDopsEvaluationsSurgeries(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDopsEvaluation interface{}, mods queries.Applicator) error {
	var slice []*DopsEvaluation
	var object *DopsEvaluation

	if singular {
		object = maybeDopsEvaluation.(*DopsEvaluation)
	} else {
		slice = *maybeDopsEvaluation.(*[]*DopsEvaluation)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dopsEvaluationR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dopsEvaluationR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`dops_evaluations_surgeries`),
		qm.WhereIn(`dops_evaluations_surgeries.dops_evaluation_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dops_evaluations_surgeries")
	}

	var resultSlice []*DopsEvaluationsSurgery
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dops_evaluations_surgeries")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dops_evaluations_surgeries")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dops_evaluations_surgeries")
	}

	if len(dopsEvaluationsSurgeryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DopsEvaluationsSurgeries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dopsEvaluationsSurgeryR{}
			}
			foreign.R.DopsEvaluation = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.DopsEvaluationID {
				local.R.DopsEvaluationsSurgeries = append(local.R.DopsEvaluationsSurgeries, foreign)
				if foreign.R == nil {
					foreign.R = &dopsEvaluationsSurgeryR{}
				}
				foreign.R.DopsEvaluation = local
				break
			}
		}
	}

	return nil
}

// SetDepartment of the dopsEvaluation to the related item.
// Sets o.R.Department to related.
// Adds o to related.R.DepartmentDopsEvaluations.
func (o *DopsEvaluation) SetDepartment(ctx context.Context, exec boil.ContextExecutor, insert bool, related *OrganizationalUnit) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"dops_evaluations\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"department_id"}),
		strmangle.WhereClause("\"", "\"", 2, dopsEvaluationPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DepartmentID, related.ID)
	if o.R == nil {
		o.R = &dopsEvaluationR{
			Department: related,
		}
	} else {
		o.R.Department = related
	}

	if related.R == nil {
		related.R = &organizationalUnitR{
			DepartmentDopsEvaluations: DopsEvaluationSlice{o},
		}
	} else {
		related.R.DepartmentDopsEvaluations = append(related.R.DepartmentDopsEvaluations, o)
	}

	return nil
}

// RemoveDepartment relationship.
// Sets o.R.Department to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DopsEvaluation) RemoveDepartment(ctx context.Context, exec boil.ContextExecutor, related *OrganizationalUnit) error {
	var err error

	queries.SetScanner(&o.DepartmentID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("department_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Department = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.DepartmentDopsEvaluations {
		if queries.Equal(o.DepartmentID, ri.DepartmentID) {
			continue
		}

		ln := len(related.R.DepartmentDopsEvaluations)
		if ln > 1 && i < ln-1 {
			related.R.DepartmentDopsEvaluations[i] = related.R.DepartmentDopsEvaluations[ln-1]
		}
		related.R.DepartmentDopsEvaluations = related.R.DepartmentDopsEvaluations[:ln-1]
		break
	}
	return nil
}

// SetOrthopedicSurgeryActivity of the dopsEvaluation to the related item.
// Sets o.R.OrthopedicSurgeryActivity to related.
// Adds o to related.R.DopsEvaluation.
func (o *DopsEvaluation) SetOrthopedicSurgeryActivity(ctx context.Context, exec boil.ContextExecutor, insert bool, related *OrthopedicSurgeryActivity) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"dops_evaluations\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"orthopedic_surgery_activity_id"}),
		strmangle.WhereClause("\"", "\"", 2, dopsEvaluationPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.OrthopedicSurgeryActivityID, related.ID)
	if o.R == nil {
		o.R = &dopsEvaluationR{
			OrthopedicSurgeryActivity: related,
		}
	} else {
		o.R.OrthopedicSurgeryActivity = related
	}

	if related.R == nil {
		related.R = &orthopedicSurgeryActivityR{
			DopsEvaluation: o,
		}
	} else {
		related.R.DopsEvaluation = o
	}

	return nil
}

// RemoveOrthopedicSurgeryActivity relationship.
// Sets o.R.OrthopedicSurgeryActivity to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DopsEvaluation) RemoveOrthopedicSurgeryActivity(ctx context.Context, exec boil.ContextExecutor, related *OrthopedicSurgeryActivity) error {
	var err error

	queries.SetScanner(&o.OrthopedicSurgeryActivityID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("orthopedic_surgery_activity_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.OrthopedicSurgeryActivity = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	related.R.DopsEvaluation = nil
	return nil
}

// SetResident of the dopsEvaluation to the related item.
// Sets o.R.Resident to related.
// Adds o to related.R.ResidentDopsEvaluations.
func (o *DopsEvaluation) SetResident(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"dops_evaluations\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"resident_id"}),
		strmangle.WhereClause("\"", "\"", 2, dopsEvaluationPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ResidentID = related.ID
	if o.R == nil {
		o.R = &dopsEvaluationR{
			Resident: related,
		}
	} else {
		o.R.Resident = related
	}

	if related.R == nil {
		related.R = &userR{
			ResidentDopsEvaluations: DopsEvaluationSlice{o},
		}
	} else {
		related.R.ResidentDopsEvaluations = append(related.R.ResidentDopsEvaluations, o)
	}

	return nil
}

// SetSupervisor of the dopsEvaluation to the related item.
// Sets o.R.Supervisor to related.
// Adds o to related.R.SupervisorDopsEvaluations.
func (o *DopsEvaluation) SetSupervisor(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"dops_evaluations\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"supervisor_id"}),
		strmangle.WhereClause("\"", "\"", 2, dopsEvaluationPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.SupervisorID = related.ID
	if o.R == nil {
		o.R = &dopsEvaluationR{
			Supervisor: related,
		}
	} else {
		o.R.Supervisor = related
	}

	if related.R == nil {
		related.R = &userR{
			SupervisorDopsEvaluations: DopsEvaluationSlice{o},
		}
	} else {
		related.R.SupervisorDopsEvaluations = append(related.R.SupervisorDopsEvaluations, o)
	}

	return nil
}

// SetDopAssessment of the dopsEvaluation to the related item.
// Sets o.R.DopAssessment to related.
// Adds o to related.R.Dop.
func (o *DopsEvaluation) SetDopAssessment(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Assessment) error {
	var err error

	if insert {
		queries.Assign(&related.DopsID, o.ID)

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"assessments\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"dops_id"}),
			strmangle.WhereClause("\"", "\"", 2, assessmentPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.DopsID, o.ID)
	}

	if o.R == nil {
		o.R = &dopsEvaluationR{
			DopAssessment: related,
		}
	} else {
		o.R.DopAssessment = related
	}

	if related.R == nil {
		related.R = &assessmentR{
			Dop: o,
		}
	} else {
		related.R.Dop = o
	}
	return nil
}

// RemoveDopAssessment relationship.
// Sets o.R.DopAssessment to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *DopsEvaluation) RemoveDopAssessment(ctx context.Context, exec boil.ContextExecutor, related *Assessment) error {
	var err error

	queries.SetScanner(&related.DopsID, nil)
	if _, err = related.Update(ctx, exec, boil.Whitelist("dops_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DopAssessment = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	related.R.Dop = nil
	return nil
}

// AddDopsEvaluationsSurgeries adds the given related objects to the existing relationships
// of the dops_evaluation, optionally inserting them as new records.
// Appends related to o.R.DopsEvaluationsSurgeries.
// Sets related.R.DopsEvaluation appropriately.
func (o *DopsEvaluation) AddDopsEvaluationsSurgeries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DopsEvaluationsSurgery) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DopsEvaluationID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"dops_evaluations_surgeries\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"dops_evaluation_id"}),
				strmangle.WhereClause("\"", "\"", 2, dopsEvaluationsSurgeryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DopsEvaluationID = o.ID
		}
	}

	if o.R == nil {
		o.R = &dopsEvaluationR{
			DopsEvaluationsSurgeries: related,
		}
	} else {
		o.R.DopsEvaluationsSurgeries = append(o.R.DopsEvaluationsSurgeries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dopsEvaluationsSurgeryR{
				DopsEvaluation: o,
			}
		} else {
			rel.R.DopsEvaluation = o
		}
	}
	return nil
}

// DopsEvaluations retrieves all the records using an executor.
func DopsEvaluations(mods ...qm.QueryMod) dopsEvaluationQuery {
	mods = append(mods, qm.From("\"dops_evaluations\""))
	return dopsEvaluationQuery{NewQuery(mods...)}
}

// FindDopsEvaluation retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDopsEvaluation(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*DopsEvaluation, error) {
	dopsEvaluationObj := &DopsEvaluation{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"dops_evaluations\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, dopsEvaluationObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from dops_evaluations")
	}

	if err = dopsEvaluationObj.doAfterSelectHooks(ctx, exec); err != nil {
		return dopsEvaluationObj, err
	}

	return dopsEvaluationObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DopsEvaluation) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no dops_evaluations provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dopsEvaluationColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dopsEvaluationInsertCacheMut.RLock()
	cache, cached := dopsEvaluationInsertCache[key]
	dopsEvaluationInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dopsEvaluationAllColumns,
			dopsEvaluationColumnsWithDefault,
			dopsEvaluationColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dopsEvaluationType, dopsEvaluationMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dopsEvaluationType, dopsEvaluationMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"dops_evaluations\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"dops_evaluations\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into dops_evaluations")
	}

	if !cached {
		dopsEvaluationInsertCacheMut.Lock()
		dopsEvaluationInsertCache[key] = cache
		dopsEvaluationInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the DopsEvaluation.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DopsEvaluation) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	dopsEvaluationUpdateCacheMut.RLock()
	cache, cached := dopsEvaluationUpdateCache[key]
	dopsEvaluationUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dopsEvaluationAllColumns,
			dopsEvaluationPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update dops_evaluations, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"dops_evaluations\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, dopsEvaluationPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dopsEvaluationType, dopsEvaluationMapping, append(wl, dopsEvaluationPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update dops_evaluations row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for dops_evaluations")
	}

	if !cached {
		dopsEvaluationUpdateCacheMut.Lock()
		dopsEvaluationUpdateCache[key] = cache
		dopsEvaluationUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q dopsEvaluationQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for dops_evaluations")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for dops_evaluations")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DopsEvaluationSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dopsEvaluationPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"dops_evaluations\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, dopsEvaluationPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in dopsEvaluation slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all dopsEvaluation")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DopsEvaluation) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no dops_evaluations provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dopsEvaluationColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dopsEvaluationUpsertCacheMut.RLock()
	cache, cached := dopsEvaluationUpsertCache[key]
	dopsEvaluationUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dopsEvaluationAllColumns,
			dopsEvaluationColumnsWithDefault,
			dopsEvaluationColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			dopsEvaluationAllColumns,
			dopsEvaluationPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert dops_evaluations, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(dopsEvaluationPrimaryKeyColumns))
			copy(conflict, dopsEvaluationPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"dops_evaluations\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(dopsEvaluationType, dopsEvaluationMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dopsEvaluationType, dopsEvaluationMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert dops_evaluations")
	}

	if !cached {
		dopsEvaluationUpsertCacheMut.Lock()
		dopsEvaluationUpsertCache[key] = cache
		dopsEvaluationUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single DopsEvaluation record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DopsEvaluation) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no DopsEvaluation provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dopsEvaluationPrimaryKeyMapping)
	sql := "DELETE FROM \"dops_evaluations\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from dops_evaluations")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for dops_evaluations")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q dopsEvaluationQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no dopsEvaluationQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from dops_evaluations")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for dops_evaluations")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DopsEvaluationSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(dopsEvaluationBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dopsEvaluationPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"dops_evaluations\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, dopsEvaluationPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from dopsEvaluation slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for dops_evaluations")
	}

	if len(dopsEvaluationAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DopsEvaluation) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDopsEvaluation(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DopsEvaluationSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DopsEvaluationSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dopsEvaluationPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"dops_evaluations\".* FROM \"dops_evaluations\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, dopsEvaluationPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in DopsEvaluationSlice")
	}

	*o = slice

	return nil
}

// DopsEvaluationExists checks if the DopsEvaluation row exists.
func DopsEvaluationExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"dops_evaluations\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if dops_evaluations exists")
	}

	return exists, nil
}
