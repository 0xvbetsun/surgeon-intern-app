// Code generated by SQLBoiler 4.8.3 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"bytes"
	"context"
	"reflect"
	"testing"

	"github.com/volatiletech/randomize"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/strmangle"
)

var (
	// Relationships sometimes use the reflection helper queries.Equal/queries.Assign
	// so force a package dependency in case they don't.
	_ = queries.Equal
)

func testOrganizationalUnits(t *testing.T) {
	t.Parallel()

	query := OrganizationalUnits()

	if query.Query == nil {
		t.Error("expected a query, got nothing")
	}
}

func testOrganizationalUnitsDelete(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	o := &OrganizationalUnit{}
	if err = randomize.Struct(seed, o, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()
	if err = o.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	}

	if rowsAff, err := o.Delete(ctx, tx); err != nil {
		t.Error(err)
	} else if rowsAff != 1 {
		t.Error("should only have deleted one row, but affected:", rowsAff)
	}

	count, err := OrganizationalUnits().Count(ctx, tx)
	if err != nil {
		t.Error(err)
	}

	if count != 0 {
		t.Error("want zero records, got:", count)
	}
}

func testOrganizationalUnitsQueryDeleteAll(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	o := &OrganizationalUnit{}
	if err = randomize.Struct(seed, o, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()
	if err = o.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	}

	if rowsAff, err := OrganizationalUnits().DeleteAll(ctx, tx); err != nil {
		t.Error(err)
	} else if rowsAff != 1 {
		t.Error("should only have deleted one row, but affected:", rowsAff)
	}

	count, err := OrganizationalUnits().Count(ctx, tx)
	if err != nil {
		t.Error(err)
	}

	if count != 0 {
		t.Error("want zero records, got:", count)
	}
}

func testOrganizationalUnitsSliceDeleteAll(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	o := &OrganizationalUnit{}
	if err = randomize.Struct(seed, o, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()
	if err = o.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	}

	slice := OrganizationalUnitSlice{o}

	if rowsAff, err := slice.DeleteAll(ctx, tx); err != nil {
		t.Error(err)
	} else if rowsAff != 1 {
		t.Error("should only have deleted one row, but affected:", rowsAff)
	}

	count, err := OrganizationalUnits().Count(ctx, tx)
	if err != nil {
		t.Error(err)
	}

	if count != 0 {
		t.Error("want zero records, got:", count)
	}
}

func testOrganizationalUnitsExists(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	o := &OrganizationalUnit{}
	if err = randomize.Struct(seed, o, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()
	if err = o.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	}

	e, err := OrganizationalUnitExists(ctx, tx, o.ID)
	if err != nil {
		t.Errorf("Unable to check if OrganizationalUnit exists: %s", err)
	}
	if !e {
		t.Errorf("Expected OrganizationalUnitExists to return true, but got false.")
	}
}

func testOrganizationalUnitsFind(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	o := &OrganizationalUnit{}
	if err = randomize.Struct(seed, o, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()
	if err = o.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	}

	organizationalUnitFound, err := FindOrganizationalUnit(ctx, tx, o.ID)
	if err != nil {
		t.Error(err)
	}

	if organizationalUnitFound == nil {
		t.Error("want a record, got nil")
	}
}

func testOrganizationalUnitsBind(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	o := &OrganizationalUnit{}
	if err = randomize.Struct(seed, o, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()
	if err = o.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	}

	if err = OrganizationalUnits().Bind(ctx, tx, o); err != nil {
		t.Error(err)
	}
}

func testOrganizationalUnitsOne(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	o := &OrganizationalUnit{}
	if err = randomize.Struct(seed, o, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()
	if err = o.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	}

	if x, err := OrganizationalUnits().One(ctx, tx); err != nil {
		t.Error(err)
	} else if x == nil {
		t.Error("expected to get a non nil record")
	}
}

func testOrganizationalUnitsAll(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	organizationalUnitOne := &OrganizationalUnit{}
	organizationalUnitTwo := &OrganizationalUnit{}
	if err = randomize.Struct(seed, organizationalUnitOne, organizationalUnitDBTypes, false, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}
	if err = randomize.Struct(seed, organizationalUnitTwo, organizationalUnitDBTypes, false, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()
	if err = organizationalUnitOne.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	}
	if err = organizationalUnitTwo.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	}

	slice, err := OrganizationalUnits().All(ctx, tx)
	if err != nil {
		t.Error(err)
	}

	if len(slice) != 2 {
		t.Error("want 2 records, got:", len(slice))
	}
}

func testOrganizationalUnitsCount(t *testing.T) {
	t.Parallel()

	var err error
	seed := randomize.NewSeed()
	organizationalUnitOne := &OrganizationalUnit{}
	organizationalUnitTwo := &OrganizationalUnit{}
	if err = randomize.Struct(seed, organizationalUnitOne, organizationalUnitDBTypes, false, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}
	if err = randomize.Struct(seed, organizationalUnitTwo, organizationalUnitDBTypes, false, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()
	if err = organizationalUnitOne.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	}
	if err = organizationalUnitTwo.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	}

	count, err := OrganizationalUnits().Count(ctx, tx)
	if err != nil {
		t.Error(err)
	}

	if count != 2 {
		t.Error("want 2 records, got:", count)
	}
}

func organizationalUnitBeforeInsertHook(ctx context.Context, e boil.ContextExecutor, o *OrganizationalUnit) error {
	*o = OrganizationalUnit{}
	return nil
}

func organizationalUnitAfterInsertHook(ctx context.Context, e boil.ContextExecutor, o *OrganizationalUnit) error {
	*o = OrganizationalUnit{}
	return nil
}

func organizationalUnitAfterSelectHook(ctx context.Context, e boil.ContextExecutor, o *OrganizationalUnit) error {
	*o = OrganizationalUnit{}
	return nil
}

func organizationalUnitBeforeUpdateHook(ctx context.Context, e boil.ContextExecutor, o *OrganizationalUnit) error {
	*o = OrganizationalUnit{}
	return nil
}

func organizationalUnitAfterUpdateHook(ctx context.Context, e boil.ContextExecutor, o *OrganizationalUnit) error {
	*o = OrganizationalUnit{}
	return nil
}

func organizationalUnitBeforeDeleteHook(ctx context.Context, e boil.ContextExecutor, o *OrganizationalUnit) error {
	*o = OrganizationalUnit{}
	return nil
}

func organizationalUnitAfterDeleteHook(ctx context.Context, e boil.ContextExecutor, o *OrganizationalUnit) error {
	*o = OrganizationalUnit{}
	return nil
}

func organizationalUnitBeforeUpsertHook(ctx context.Context, e boil.ContextExecutor, o *OrganizationalUnit) error {
	*o = OrganizationalUnit{}
	return nil
}

func organizationalUnitAfterUpsertHook(ctx context.Context, e boil.ContextExecutor, o *OrganizationalUnit) error {
	*o = OrganizationalUnit{}
	return nil
}

func testOrganizationalUnitsHooks(t *testing.T) {
	t.Parallel()

	var err error

	ctx := context.Background()
	empty := &OrganizationalUnit{}
	o := &OrganizationalUnit{}

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, o, organizationalUnitDBTypes, false); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit object: %s", err)
	}

	AddOrganizationalUnitHook(boil.BeforeInsertHook, organizationalUnitBeforeInsertHook)
	if err = o.doBeforeInsertHooks(ctx, nil); err != nil {
		t.Errorf("Unable to execute doBeforeInsertHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected BeforeInsertHook function to empty object, but got: %#v", o)
	}
	organizationalUnitBeforeInsertHooks = []OrganizationalUnitHook{}

	AddOrganizationalUnitHook(boil.AfterInsertHook, organizationalUnitAfterInsertHook)
	if err = o.doAfterInsertHooks(ctx, nil); err != nil {
		t.Errorf("Unable to execute doAfterInsertHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected AfterInsertHook function to empty object, but got: %#v", o)
	}
	organizationalUnitAfterInsertHooks = []OrganizationalUnitHook{}

	AddOrganizationalUnitHook(boil.AfterSelectHook, organizationalUnitAfterSelectHook)
	if err = o.doAfterSelectHooks(ctx, nil); err != nil {
		t.Errorf("Unable to execute doAfterSelectHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected AfterSelectHook function to empty object, but got: %#v", o)
	}
	organizationalUnitAfterSelectHooks = []OrganizationalUnitHook{}

	AddOrganizationalUnitHook(boil.BeforeUpdateHook, organizationalUnitBeforeUpdateHook)
	if err = o.doBeforeUpdateHooks(ctx, nil); err != nil {
		t.Errorf("Unable to execute doBeforeUpdateHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected BeforeUpdateHook function to empty object, but got: %#v", o)
	}
	organizationalUnitBeforeUpdateHooks = []OrganizationalUnitHook{}

	AddOrganizationalUnitHook(boil.AfterUpdateHook, organizationalUnitAfterUpdateHook)
	if err = o.doAfterUpdateHooks(ctx, nil); err != nil {
		t.Errorf("Unable to execute doAfterUpdateHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected AfterUpdateHook function to empty object, but got: %#v", o)
	}
	organizationalUnitAfterUpdateHooks = []OrganizationalUnitHook{}

	AddOrganizationalUnitHook(boil.BeforeDeleteHook, organizationalUnitBeforeDeleteHook)
	if err = o.doBeforeDeleteHooks(ctx, nil); err != nil {
		t.Errorf("Unable to execute doBeforeDeleteHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected BeforeDeleteHook function to empty object, but got: %#v", o)
	}
	organizationalUnitBeforeDeleteHooks = []OrganizationalUnitHook{}

	AddOrganizationalUnitHook(boil.AfterDeleteHook, organizationalUnitAfterDeleteHook)
	if err = o.doAfterDeleteHooks(ctx, nil); err != nil {
		t.Errorf("Unable to execute doAfterDeleteHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected AfterDeleteHook function to empty object, but got: %#v", o)
	}
	organizationalUnitAfterDeleteHooks = []OrganizationalUnitHook{}

	AddOrganizationalUnitHook(boil.BeforeUpsertHook, organizationalUnitBeforeUpsertHook)
	if err = o.doBeforeUpsertHooks(ctx, nil); err != nil {
		t.Errorf("Unable to execute doBeforeUpsertHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected BeforeUpsertHook function to empty object, but got: %#v", o)
	}
	organizationalUnitBeforeUpsertHooks = []OrganizationalUnitHook{}

	AddOrganizationalUnitHook(boil.AfterUpsertHook, organizationalUnitAfterUpsertHook)
	if err = o.doAfterUpsertHooks(ctx, nil); err != nil {
		t.Errorf("Unable to execute doAfterUpsertHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected AfterUpsertHook function to empty object, but got: %#v", o)
	}
	organizationalUnitAfterUpsertHooks = []OrganizationalUnitHook{}
}

func testOrganizationalUnitsInsert(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	o := &OrganizationalUnit{}
	if err = randomize.Struct(seed, o, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()
	if err = o.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	}

	count, err := OrganizationalUnits().Count(ctx, tx)
	if err != nil {
		t.Error(err)
	}

	if count != 1 {
		t.Error("want one record, got:", count)
	}
}

func testOrganizationalUnitsInsertWhitelist(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	o := &OrganizationalUnit{}
	if err = randomize.Struct(seed, o, organizationalUnitDBTypes, true); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()
	if err = o.Insert(ctx, tx, boil.Whitelist(organizationalUnitColumnsWithoutDefault...)); err != nil {
		t.Error(err)
	}

	count, err := OrganizationalUnits().Count(ctx, tx)
	if err != nil {
		t.Error(err)
	}

	if count != 1 {
		t.Error("want one record, got:", count)
	}
}

func testOrganizationalUnitToManyDepartmentDopsEvaluations(t *testing.T) {
	var err error
	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c DopsEvaluation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	if err = randomize.Struct(seed, &b, dopsEvaluationDBTypes, false, dopsEvaluationColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &c, dopsEvaluationDBTypes, false, dopsEvaluationColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}

	queries.Assign(&b.DepartmentID, a.ID)
	queries.Assign(&c.DepartmentID, a.ID)
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	check, err := a.DepartmentDopsEvaluations().All(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range check {
		if queries.Equal(v.DepartmentID, b.DepartmentID) {
			bFound = true
		}
		if queries.Equal(v.DepartmentID, c.DepartmentID) {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := OrganizationalUnitSlice{&a}
	if err = a.L.LoadDepartmentDopsEvaluations(ctx, tx, false, (*[]*OrganizationalUnit)(&slice), nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.DepartmentDopsEvaluations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.DepartmentDopsEvaluations = nil
	if err = a.L.LoadDepartmentDopsEvaluations(ctx, tx, true, &a, nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.DepartmentDopsEvaluations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", check)
	}
}

func testOrganizationalUnitToManyDepartmentEvaluationForms(t *testing.T) {
	var err error
	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c EvaluationForm

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	if err = randomize.Struct(seed, &b, evaluationFormDBTypes, false, evaluationFormColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &c, evaluationFormDBTypes, false, evaluationFormColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}

	b.DepartmentID = a.ID
	c.DepartmentID = a.ID

	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	check, err := a.DepartmentEvaluationForms().All(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range check {
		if v.DepartmentID == b.DepartmentID {
			bFound = true
		}
		if v.DepartmentID == c.DepartmentID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := OrganizationalUnitSlice{&a}
	if err = a.L.LoadDepartmentEvaluationForms(ctx, tx, false, (*[]*OrganizationalUnit)(&slice), nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.DepartmentEvaluationForms); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.DepartmentEvaluationForms = nil
	if err = a.L.LoadDepartmentEvaluationForms(ctx, tx, true, &a, nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.DepartmentEvaluationForms); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", check)
	}
}

func testOrganizationalUnitToManyDepartmentExaminations(t *testing.T) {
	var err error
	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c Examination

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	if err = randomize.Struct(seed, &b, examinationDBTypes, false, examinationColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &c, examinationDBTypes, false, examinationColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}

	b.DepartmentID = a.ID
	c.DepartmentID = a.ID

	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	check, err := a.DepartmentExaminations().All(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range check {
		if v.DepartmentID == b.DepartmentID {
			bFound = true
		}
		if v.DepartmentID == c.DepartmentID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := OrganizationalUnitSlice{&a}
	if err = a.L.LoadDepartmentExaminations(ctx, tx, false, (*[]*OrganizationalUnit)(&slice), nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.DepartmentExaminations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.DepartmentExaminations = nil
	if err = a.L.LoadDepartmentExaminations(ctx, tx, true, &a, nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.DepartmentExaminations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", check)
	}
}

func testOrganizationalUnitToManyDepartmentMiniCexAreas(t *testing.T) {
	var err error
	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c MiniCexArea

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	if err = randomize.Struct(seed, &b, miniCexAreaDBTypes, false, miniCexAreaColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &c, miniCexAreaDBTypes, false, miniCexAreaColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}

	b.DepartmentID = a.ID
	c.DepartmentID = a.ID

	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	check, err := a.DepartmentMiniCexAreas().All(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range check {
		if v.DepartmentID == b.DepartmentID {
			bFound = true
		}
		if v.DepartmentID == c.DepartmentID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := OrganizationalUnitSlice{&a}
	if err = a.L.LoadDepartmentMiniCexAreas(ctx, tx, false, (*[]*OrganizationalUnit)(&slice), nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.DepartmentMiniCexAreas); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.DepartmentMiniCexAreas = nil
	if err = a.L.LoadDepartmentMiniCexAreas(ctx, tx, true, &a, nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.DepartmentMiniCexAreas); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", check)
	}
}

func testOrganizationalUnitToManyDepartmentMiniCexEvaluations(t *testing.T) {
	var err error
	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c MiniCexEvaluation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	if err = randomize.Struct(seed, &b, miniCexEvaluationDBTypes, false, miniCexEvaluationColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &c, miniCexEvaluationDBTypes, false, miniCexEvaluationColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}

	queries.Assign(&b.DepartmentID, a.ID)
	queries.Assign(&c.DepartmentID, a.ID)
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	check, err := a.DepartmentMiniCexEvaluations().All(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range check {
		if queries.Equal(v.DepartmentID, b.DepartmentID) {
			bFound = true
		}
		if queries.Equal(v.DepartmentID, c.DepartmentID) {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := OrganizationalUnitSlice{&a}
	if err = a.L.LoadDepartmentMiniCexEvaluations(ctx, tx, false, (*[]*OrganizationalUnit)(&slice), nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.DepartmentMiniCexEvaluations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.DepartmentMiniCexEvaluations = nil
	if err = a.L.LoadDepartmentMiniCexEvaluations(ctx, tx, true, &a, nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.DepartmentMiniCexEvaluations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", check)
	}
}

func testOrganizationalUnitToManySpecialties(t *testing.T) {
	var err error
	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c Specialty

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	if err = randomize.Struct(seed, &b, specialtyDBTypes, false, specialtyColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &c, specialtyDBTypes, false, specialtyColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}

	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	_, err = tx.Exec("insert into \"organizational_unit_specialties\" (\"unit_id\", \"specialty_id\") values ($1, $2)", a.ID, b.ID)
	if err != nil {
		t.Fatal(err)
	}
	_, err = tx.Exec("insert into \"organizational_unit_specialties\" (\"unit_id\", \"specialty_id\") values ($1, $2)", a.ID, c.ID)
	if err != nil {
		t.Fatal(err)
	}

	check, err := a.Specialties().All(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range check {
		if v.ID == b.ID {
			bFound = true
		}
		if v.ID == c.ID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := OrganizationalUnitSlice{&a}
	if err = a.L.LoadSpecialties(ctx, tx, false, (*[]*OrganizationalUnit)(&slice), nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.Specialties); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.Specialties = nil
	if err = a.L.LoadSpecialties(ctx, tx, true, &a, nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.Specialties); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", check)
	}
}

func testOrganizationalUnitToManyParentOrganizationalUnits(t *testing.T) {
	var err error
	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c OrganizationalUnit

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	if err = randomize.Struct(seed, &b, organizationalUnitDBTypes, false, organizationalUnitColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &c, organizationalUnitDBTypes, false, organizationalUnitColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}

	queries.Assign(&b.ParentID, a.ID)
	queries.Assign(&c.ParentID, a.ID)
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	check, err := a.ParentOrganizationalUnits().All(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range check {
		if queries.Equal(v.ParentID, b.ParentID) {
			bFound = true
		}
		if queries.Equal(v.ParentID, c.ParentID) {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := OrganizationalUnitSlice{&a}
	if err = a.L.LoadParentOrganizationalUnits(ctx, tx, false, (*[]*OrganizationalUnit)(&slice), nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.ParentOrganizationalUnits); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.ParentOrganizationalUnits = nil
	if err = a.L.LoadParentOrganizationalUnits(ctx, tx, true, &a, nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.ParentOrganizationalUnits); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", check)
	}
}

func testOrganizationalUnitToManyProcedures(t *testing.T) {
	var err error
	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c Procedure

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	if err = randomize.Struct(seed, &b, procedureDBTypes, false, procedureColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &c, procedureDBTypes, false, procedureColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}

	b.OrganizationalUnitID = a.ID
	c.OrganizationalUnitID = a.ID

	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	check, err := a.Procedures().All(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range check {
		if v.OrganizationalUnitID == b.OrganizationalUnitID {
			bFound = true
		}
		if v.OrganizationalUnitID == c.OrganizationalUnitID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := OrganizationalUnitSlice{&a}
	if err = a.L.LoadProcedures(ctx, tx, false, (*[]*OrganizationalUnit)(&slice), nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.Procedures); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.Procedures = nil
	if err = a.L.LoadProcedures(ctx, tx, true, &a, nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.Procedures); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", check)
	}
}

func testOrganizationalUnitToManyUnitUserOrganizationalUnitRoles(t *testing.T) {
	var err error
	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c UserOrganizationalUnitRole

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	if err = randomize.Struct(seed, &b, userOrganizationalUnitRoleDBTypes, false, userOrganizationalUnitRoleColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &c, userOrganizationalUnitRoleDBTypes, false, userOrganizationalUnitRoleColumnsWithDefault...); err != nil {
		t.Fatal(err)
	}

	b.UnitID = a.ID
	c.UnitID = a.ID

	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	check, err := a.UnitUserOrganizationalUnitRoles().All(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range check {
		if v.UnitID == b.UnitID {
			bFound = true
		}
		if v.UnitID == c.UnitID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := OrganizationalUnitSlice{&a}
	if err = a.L.LoadUnitUserOrganizationalUnitRoles(ctx, tx, false, (*[]*OrganizationalUnit)(&slice), nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.UnitUserOrganizationalUnitRoles); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.UnitUserOrganizationalUnitRoles = nil
	if err = a.L.LoadUnitUserOrganizationalUnitRoles(ctx, tx, true, &a, nil); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.UnitUserOrganizationalUnitRoles); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", check)
	}
}

func testOrganizationalUnitToManyAddOpDepartmentDopsEvaluations(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c, d, e DopsEvaluation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*DopsEvaluation{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, dopsEvaluationDBTypes, false, strmangle.SetComplement(dopsEvaluationPrimaryKeyColumns, dopsEvaluationColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*DopsEvaluation{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddDepartmentDopsEvaluations(ctx, tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if !queries.Equal(a.ID, first.DepartmentID) {
			t.Error("foreign key was wrong value", a.ID, first.DepartmentID)
		}
		if !queries.Equal(a.ID, second.DepartmentID) {
			t.Error("foreign key was wrong value", a.ID, second.DepartmentID)
		}

		if first.R.Department != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.Department != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.DepartmentDopsEvaluations[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.DepartmentDopsEvaluations[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.DepartmentDopsEvaluations().Count(ctx, tx)
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}

func testOrganizationalUnitToManySetOpDepartmentDopsEvaluations(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c, d, e DopsEvaluation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*DopsEvaluation{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, dopsEvaluationDBTypes, false, strmangle.SetComplement(dopsEvaluationPrimaryKeyColumns, dopsEvaluationColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err = a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	err = a.SetDepartmentDopsEvaluations(ctx, tx, false, &b, &c)
	if err != nil {
		t.Fatal(err)
	}

	count, err := a.DepartmentDopsEvaluations().Count(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}
	if count != 2 {
		t.Error("count was wrong:", count)
	}

	err = a.SetDepartmentDopsEvaluations(ctx, tx, true, &d, &e)
	if err != nil {
		t.Fatal(err)
	}

	count, err = a.DepartmentDopsEvaluations().Count(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}
	if count != 2 {
		t.Error("count was wrong:", count)
	}

	if !queries.IsValuerNil(b.DepartmentID) {
		t.Error("want b's foreign key value to be nil")
	}
	if !queries.IsValuerNil(c.DepartmentID) {
		t.Error("want c's foreign key value to be nil")
	}
	if !queries.Equal(a.ID, d.DepartmentID) {
		t.Error("foreign key was wrong value", a.ID, d.DepartmentID)
	}
	if !queries.Equal(a.ID, e.DepartmentID) {
		t.Error("foreign key was wrong value", a.ID, e.DepartmentID)
	}

	if b.R.Department != nil {
		t.Error("relationship was not removed properly from the foreign struct")
	}
	if c.R.Department != nil {
		t.Error("relationship was not removed properly from the foreign struct")
	}
	if d.R.Department != &a {
		t.Error("relationship was not added properly to the foreign struct")
	}
	if e.R.Department != &a {
		t.Error("relationship was not added properly to the foreign struct")
	}

	if a.R.DepartmentDopsEvaluations[0] != &d {
		t.Error("relationship struct slice not set to correct value")
	}
	if a.R.DepartmentDopsEvaluations[1] != &e {
		t.Error("relationship struct slice not set to correct value")
	}
}

func testOrganizationalUnitToManyRemoveOpDepartmentDopsEvaluations(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c, d, e DopsEvaluation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*DopsEvaluation{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, dopsEvaluationDBTypes, false, strmangle.SetComplement(dopsEvaluationPrimaryKeyColumns, dopsEvaluationColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	err = a.AddDepartmentDopsEvaluations(ctx, tx, true, foreigners...)
	if err != nil {
		t.Fatal(err)
	}

	count, err := a.DepartmentDopsEvaluations().Count(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}
	if count != 4 {
		t.Error("count was wrong:", count)
	}

	err = a.RemoveDepartmentDopsEvaluations(ctx, tx, foreigners[:2]...)
	if err != nil {
		t.Fatal(err)
	}

	count, err = a.DepartmentDopsEvaluations().Count(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}
	if count != 2 {
		t.Error("count was wrong:", count)
	}

	if !queries.IsValuerNil(b.DepartmentID) {
		t.Error("want b's foreign key value to be nil")
	}
	if !queries.IsValuerNil(c.DepartmentID) {
		t.Error("want c's foreign key value to be nil")
	}

	if b.R.Department != nil {
		t.Error("relationship was not removed properly from the foreign struct")
	}
	if c.R.Department != nil {
		t.Error("relationship was not removed properly from the foreign struct")
	}
	if d.R.Department != &a {
		t.Error("relationship to a should have been preserved")
	}
	if e.R.Department != &a {
		t.Error("relationship to a should have been preserved")
	}

	if len(a.R.DepartmentDopsEvaluations) != 2 {
		t.Error("should have preserved two relationships")
	}

	// Removal doesn't do a stable deletion for performance so we have to flip the order
	if a.R.DepartmentDopsEvaluations[1] != &d {
		t.Error("relationship to d should have been preserved")
	}
	if a.R.DepartmentDopsEvaluations[0] != &e {
		t.Error("relationship to e should have been preserved")
	}
}

func testOrganizationalUnitToManyAddOpDepartmentEvaluationForms(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c, d, e EvaluationForm

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*EvaluationForm{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, evaluationFormDBTypes, false, strmangle.SetComplement(evaluationFormPrimaryKeyColumns, evaluationFormColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*EvaluationForm{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddDepartmentEvaluationForms(ctx, tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.DepartmentID {
			t.Error("foreign key was wrong value", a.ID, first.DepartmentID)
		}
		if a.ID != second.DepartmentID {
			t.Error("foreign key was wrong value", a.ID, second.DepartmentID)
		}

		if first.R.Department != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.Department != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.DepartmentEvaluationForms[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.DepartmentEvaluationForms[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.DepartmentEvaluationForms().Count(ctx, tx)
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testOrganizationalUnitToManyAddOpDepartmentExaminations(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c, d, e Examination

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*Examination{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, examinationDBTypes, false, strmangle.SetComplement(examinationPrimaryKeyColumns, examinationColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*Examination{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddDepartmentExaminations(ctx, tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.DepartmentID {
			t.Error("foreign key was wrong value", a.ID, first.DepartmentID)
		}
		if a.ID != second.DepartmentID {
			t.Error("foreign key was wrong value", a.ID, second.DepartmentID)
		}

		if first.R.Department != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.Department != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.DepartmentExaminations[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.DepartmentExaminations[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.DepartmentExaminations().Count(ctx, tx)
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testOrganizationalUnitToManyAddOpDepartmentMiniCexAreas(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c, d, e MiniCexArea

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*MiniCexArea{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, miniCexAreaDBTypes, false, strmangle.SetComplement(miniCexAreaPrimaryKeyColumns, miniCexAreaColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*MiniCexArea{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddDepartmentMiniCexAreas(ctx, tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.DepartmentID {
			t.Error("foreign key was wrong value", a.ID, first.DepartmentID)
		}
		if a.ID != second.DepartmentID {
			t.Error("foreign key was wrong value", a.ID, second.DepartmentID)
		}

		if first.R.Department != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.Department != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.DepartmentMiniCexAreas[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.DepartmentMiniCexAreas[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.DepartmentMiniCexAreas().Count(ctx, tx)
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testOrganizationalUnitToManyAddOpDepartmentMiniCexEvaluations(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c, d, e MiniCexEvaluation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*MiniCexEvaluation{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, miniCexEvaluationDBTypes, false, strmangle.SetComplement(miniCexEvaluationPrimaryKeyColumns, miniCexEvaluationColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*MiniCexEvaluation{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddDepartmentMiniCexEvaluations(ctx, tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if !queries.Equal(a.ID, first.DepartmentID) {
			t.Error("foreign key was wrong value", a.ID, first.DepartmentID)
		}
		if !queries.Equal(a.ID, second.DepartmentID) {
			t.Error("foreign key was wrong value", a.ID, second.DepartmentID)
		}

		if first.R.Department != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.Department != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.DepartmentMiniCexEvaluations[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.DepartmentMiniCexEvaluations[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.DepartmentMiniCexEvaluations().Count(ctx, tx)
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}

func testOrganizationalUnitToManySetOpDepartmentMiniCexEvaluations(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c, d, e MiniCexEvaluation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*MiniCexEvaluation{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, miniCexEvaluationDBTypes, false, strmangle.SetComplement(miniCexEvaluationPrimaryKeyColumns, miniCexEvaluationColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err = a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	err = a.SetDepartmentMiniCexEvaluations(ctx, tx, false, &b, &c)
	if err != nil {
		t.Fatal(err)
	}

	count, err := a.DepartmentMiniCexEvaluations().Count(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}
	if count != 2 {
		t.Error("count was wrong:", count)
	}

	err = a.SetDepartmentMiniCexEvaluations(ctx, tx, true, &d, &e)
	if err != nil {
		t.Fatal(err)
	}

	count, err = a.DepartmentMiniCexEvaluations().Count(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}
	if count != 2 {
		t.Error("count was wrong:", count)
	}

	if !queries.IsValuerNil(b.DepartmentID) {
		t.Error("want b's foreign key value to be nil")
	}
	if !queries.IsValuerNil(c.DepartmentID) {
		t.Error("want c's foreign key value to be nil")
	}
	if !queries.Equal(a.ID, d.DepartmentID) {
		t.Error("foreign key was wrong value", a.ID, d.DepartmentID)
	}
	if !queries.Equal(a.ID, e.DepartmentID) {
		t.Error("foreign key was wrong value", a.ID, e.DepartmentID)
	}

	if b.R.Department != nil {
		t.Error("relationship was not removed properly from the foreign struct")
	}
	if c.R.Department != nil {
		t.Error("relationship was not removed properly from the foreign struct")
	}
	if d.R.Department != &a {
		t.Error("relationship was not added properly to the foreign struct")
	}
	if e.R.Department != &a {
		t.Error("relationship was not added properly to the foreign struct")
	}

	if a.R.DepartmentMiniCexEvaluations[0] != &d {
		t.Error("relationship struct slice not set to correct value")
	}
	if a.R.DepartmentMiniCexEvaluations[1] != &e {
		t.Error("relationship struct slice not set to correct value")
	}
}

func testOrganizationalUnitToManyRemoveOpDepartmentMiniCexEvaluations(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c, d, e MiniCexEvaluation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*MiniCexEvaluation{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, miniCexEvaluationDBTypes, false, strmangle.SetComplement(miniCexEvaluationPrimaryKeyColumns, miniCexEvaluationColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	err = a.AddDepartmentMiniCexEvaluations(ctx, tx, true, foreigners...)
	if err != nil {
		t.Fatal(err)
	}

	count, err := a.DepartmentMiniCexEvaluations().Count(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}
	if count != 4 {
		t.Error("count was wrong:", count)
	}

	err = a.RemoveDepartmentMiniCexEvaluations(ctx, tx, foreigners[:2]...)
	if err != nil {
		t.Fatal(err)
	}

	count, err = a.DepartmentMiniCexEvaluations().Count(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}
	if count != 2 {
		t.Error("count was wrong:", count)
	}

	if !queries.IsValuerNil(b.DepartmentID) {
		t.Error("want b's foreign key value to be nil")
	}
	if !queries.IsValuerNil(c.DepartmentID) {
		t.Error("want c's foreign key value to be nil")
	}

	if b.R.Department != nil {
		t.Error("relationship was not removed properly from the foreign struct")
	}
	if c.R.Department != nil {
		t.Error("relationship was not removed properly from the foreign struct")
	}
	if d.R.Department != &a {
		t.Error("relationship to a should have been preserved")
	}
	if e.R.Department != &a {
		t.Error("relationship to a should have been preserved")
	}

	if len(a.R.DepartmentMiniCexEvaluations) != 2 {
		t.Error("should have preserved two relationships")
	}

	// Removal doesn't do a stable deletion for performance so we have to flip the order
	if a.R.DepartmentMiniCexEvaluations[1] != &d {
		t.Error("relationship to d should have been preserved")
	}
	if a.R.DepartmentMiniCexEvaluations[0] != &e {
		t.Error("relationship to e should have been preserved")
	}
}

func testOrganizationalUnitToManyAddOpSpecialties(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c, d, e Specialty

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*Specialty{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, specialtyDBTypes, false, strmangle.SetComplement(specialtyPrimaryKeyColumns, specialtyColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*Specialty{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddSpecialties(ctx, tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if first.R.UnitOrganizationalUnits[0] != &a {
			t.Error("relationship was not added properly to the slice")
		}
		if second.R.UnitOrganizationalUnits[0] != &a {
			t.Error("relationship was not added properly to the slice")
		}

		if a.R.Specialties[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.Specialties[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.Specialties().Count(ctx, tx)
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}

func testOrganizationalUnitToManySetOpSpecialties(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c, d, e Specialty

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*Specialty{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, specialtyDBTypes, false, strmangle.SetComplement(specialtyPrimaryKeyColumns, specialtyColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err = a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	err = a.SetSpecialties(ctx, tx, false, &b, &c)
	if err != nil {
		t.Fatal(err)
	}

	count, err := a.Specialties().Count(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}
	if count != 2 {
		t.Error("count was wrong:", count)
	}

	err = a.SetSpecialties(ctx, tx, true, &d, &e)
	if err != nil {
		t.Fatal(err)
	}

	count, err = a.Specialties().Count(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}
	if count != 2 {
		t.Error("count was wrong:", count)
	}

	// The following checks cannot be implemented since we have no handle
	// to these when we call Set(). Leaving them here as wishful thinking
	// and to let people know there's dragons.
	//
	// if len(b.R.UnitOrganizationalUnits) != 0 {
	// 	t.Error("relationship was not removed properly from the slice")
	// }
	// if len(c.R.UnitOrganizationalUnits) != 0 {
	// 	t.Error("relationship was not removed properly from the slice")
	// }
	if d.R.UnitOrganizationalUnits[0] != &a {
		t.Error("relationship was not added properly to the slice")
	}
	if e.R.UnitOrganizationalUnits[0] != &a {
		t.Error("relationship was not added properly to the slice")
	}

	if a.R.Specialties[0] != &d {
		t.Error("relationship struct slice not set to correct value")
	}
	if a.R.Specialties[1] != &e {
		t.Error("relationship struct slice not set to correct value")
	}
}

func testOrganizationalUnitToManyRemoveOpSpecialties(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c, d, e Specialty

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*Specialty{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, specialtyDBTypes, false, strmangle.SetComplement(specialtyPrimaryKeyColumns, specialtyColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	err = a.AddSpecialties(ctx, tx, true, foreigners...)
	if err != nil {
		t.Fatal(err)
	}

	count, err := a.Specialties().Count(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}
	if count != 4 {
		t.Error("count was wrong:", count)
	}

	err = a.RemoveSpecialties(ctx, tx, foreigners[:2]...)
	if err != nil {
		t.Fatal(err)
	}

	count, err = a.Specialties().Count(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}
	if count != 2 {
		t.Error("count was wrong:", count)
	}

	if len(b.R.UnitOrganizationalUnits) != 0 {
		t.Error("relationship was not removed properly from the slice")
	}
	if len(c.R.UnitOrganizationalUnits) != 0 {
		t.Error("relationship was not removed properly from the slice")
	}
	if d.R.UnitOrganizationalUnits[0] != &a {
		t.Error("relationship was not added properly to the foreign struct")
	}
	if e.R.UnitOrganizationalUnits[0] != &a {
		t.Error("relationship was not added properly to the foreign struct")
	}

	if len(a.R.Specialties) != 2 {
		t.Error("should have preserved two relationships")
	}

	// Removal doesn't do a stable deletion for performance so we have to flip the order
	if a.R.Specialties[1] != &d {
		t.Error("relationship to d should have been preserved")
	}
	if a.R.Specialties[0] != &e {
		t.Error("relationship to e should have been preserved")
	}
}

func testOrganizationalUnitToManyAddOpParentOrganizationalUnits(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c, d, e OrganizationalUnit

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*OrganizationalUnit{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*OrganizationalUnit{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddParentOrganizationalUnits(ctx, tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if !queries.Equal(a.ID, first.ParentID) {
			t.Error("foreign key was wrong value", a.ID, first.ParentID)
		}
		if !queries.Equal(a.ID, second.ParentID) {
			t.Error("foreign key was wrong value", a.ID, second.ParentID)
		}

		if first.R.Parent != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.Parent != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.ParentOrganizationalUnits[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.ParentOrganizationalUnits[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.ParentOrganizationalUnits().Count(ctx, tx)
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}

func testOrganizationalUnitToManySetOpParentOrganizationalUnits(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c, d, e OrganizationalUnit

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*OrganizationalUnit{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err = a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	err = a.SetParentOrganizationalUnits(ctx, tx, false, &b, &c)
	if err != nil {
		t.Fatal(err)
	}

	count, err := a.ParentOrganizationalUnits().Count(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}
	if count != 2 {
		t.Error("count was wrong:", count)
	}

	err = a.SetParentOrganizationalUnits(ctx, tx, true, &d, &e)
	if err != nil {
		t.Fatal(err)
	}

	count, err = a.ParentOrganizationalUnits().Count(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}
	if count != 2 {
		t.Error("count was wrong:", count)
	}

	if !queries.IsValuerNil(b.ParentID) {
		t.Error("want b's foreign key value to be nil")
	}
	if !queries.IsValuerNil(c.ParentID) {
		t.Error("want c's foreign key value to be nil")
	}
	if !queries.Equal(a.ID, d.ParentID) {
		t.Error("foreign key was wrong value", a.ID, d.ParentID)
	}
	if !queries.Equal(a.ID, e.ParentID) {
		t.Error("foreign key was wrong value", a.ID, e.ParentID)
	}

	if b.R.Parent != nil {
		t.Error("relationship was not removed properly from the foreign struct")
	}
	if c.R.Parent != nil {
		t.Error("relationship was not removed properly from the foreign struct")
	}
	if d.R.Parent != &a {
		t.Error("relationship was not added properly to the foreign struct")
	}
	if e.R.Parent != &a {
		t.Error("relationship was not added properly to the foreign struct")
	}

	if a.R.ParentOrganizationalUnits[0] != &d {
		t.Error("relationship struct slice not set to correct value")
	}
	if a.R.ParentOrganizationalUnits[1] != &e {
		t.Error("relationship struct slice not set to correct value")
	}
}

func testOrganizationalUnitToManyRemoveOpParentOrganizationalUnits(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c, d, e OrganizationalUnit

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*OrganizationalUnit{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	err = a.AddParentOrganizationalUnits(ctx, tx, true, foreigners...)
	if err != nil {
		t.Fatal(err)
	}

	count, err := a.ParentOrganizationalUnits().Count(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}
	if count != 4 {
		t.Error("count was wrong:", count)
	}

	err = a.RemoveParentOrganizationalUnits(ctx, tx, foreigners[:2]...)
	if err != nil {
		t.Fatal(err)
	}

	count, err = a.ParentOrganizationalUnits().Count(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}
	if count != 2 {
		t.Error("count was wrong:", count)
	}

	if !queries.IsValuerNil(b.ParentID) {
		t.Error("want b's foreign key value to be nil")
	}
	if !queries.IsValuerNil(c.ParentID) {
		t.Error("want c's foreign key value to be nil")
	}

	if b.R.Parent != nil {
		t.Error("relationship was not removed properly from the foreign struct")
	}
	if c.R.Parent != nil {
		t.Error("relationship was not removed properly from the foreign struct")
	}
	if d.R.Parent != &a {
		t.Error("relationship to a should have been preserved")
	}
	if e.R.Parent != &a {
		t.Error("relationship to a should have been preserved")
	}

	if len(a.R.ParentOrganizationalUnits) != 2 {
		t.Error("should have preserved two relationships")
	}

	// Removal doesn't do a stable deletion for performance so we have to flip the order
	if a.R.ParentOrganizationalUnits[1] != &d {
		t.Error("relationship to d should have been preserved")
	}
	if a.R.ParentOrganizationalUnits[0] != &e {
		t.Error("relationship to e should have been preserved")
	}
}

func testOrganizationalUnitToManyAddOpProcedures(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c, d, e Procedure

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*Procedure{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, procedureDBTypes, false, strmangle.SetComplement(procedurePrimaryKeyColumns, procedureColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*Procedure{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddProcedures(ctx, tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.OrganizationalUnitID {
			t.Error("foreign key was wrong value", a.ID, first.OrganizationalUnitID)
		}
		if a.ID != second.OrganizationalUnitID {
			t.Error("foreign key was wrong value", a.ID, second.OrganizationalUnitID)
		}

		if first.R.OrganizationalUnit != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.OrganizationalUnit != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.Procedures[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.Procedures[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.Procedures().Count(ctx, tx)
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testOrganizationalUnitToManyAddOpUnitUserOrganizationalUnitRoles(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c, d, e UserOrganizationalUnitRole

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*UserOrganizationalUnitRole{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, userOrganizationalUnitRoleDBTypes, false, strmangle.SetComplement(userOrganizationalUnitRolePrimaryKeyColumns, userOrganizationalUnitRoleColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*UserOrganizationalUnitRole{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddUnitUserOrganizationalUnitRoles(ctx, tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.UnitID {
			t.Error("foreign key was wrong value", a.ID, first.UnitID)
		}
		if a.ID != second.UnitID {
			t.Error("foreign key was wrong value", a.ID, second.UnitID)
		}

		if first.R.Unit != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.Unit != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.UnitUserOrganizationalUnitRoles[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.UnitUserOrganizationalUnitRoles[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.UnitUserOrganizationalUnitRoles().Count(ctx, tx)
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testOrganizationalUnitToOneOrganizationalUnitUsingParent(t *testing.T) {
	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var local OrganizationalUnit
	var foreign OrganizationalUnit

	seed := randomize.NewSeed()
	if err := randomize.Struct(seed, &local, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}
	if err := randomize.Struct(seed, &foreign, organizationalUnitDBTypes, false, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	if err := foreign.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	queries.Assign(&local.ParentID, foreign.ID)
	if err := local.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	check, err := local.Parent().One(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}

	if !queries.Equal(check.ID, foreign.ID) {
		t.Errorf("want: %v, got %v", foreign.ID, check.ID)
	}

	slice := OrganizationalUnitSlice{&local}
	if err = local.L.LoadParent(ctx, tx, false, (*[]*OrganizationalUnit)(&slice), nil); err != nil {
		t.Fatal(err)
	}
	if local.R.Parent == nil {
		t.Error("struct should have been eager loaded")
	}

	local.R.Parent = nil
	if err = local.L.LoadParent(ctx, tx, true, &local, nil); err != nil {
		t.Fatal(err)
	}
	if local.R.Parent == nil {
		t.Error("struct should have been eager loaded")
	}
}

func testOrganizationalUnitToOneOrganizationalUnitTypeUsingType(t *testing.T) {
	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var local OrganizationalUnit
	var foreign OrganizationalUnitType

	seed := randomize.NewSeed()
	if err := randomize.Struct(seed, &local, organizationalUnitDBTypes, false, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}
	if err := randomize.Struct(seed, &foreign, organizationalUnitTypeDBTypes, false, organizationalUnitTypeColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnitType struct: %s", err)
	}

	if err := foreign.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	local.TypeID = foreign.ID
	if err := local.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	check, err := local.Type().One(ctx, tx)
	if err != nil {
		t.Fatal(err)
	}

	if check.ID != foreign.ID {
		t.Errorf("want: %v, got %v", foreign.ID, check.ID)
	}

	slice := OrganizationalUnitSlice{&local}
	if err = local.L.LoadType(ctx, tx, false, (*[]*OrganizationalUnit)(&slice), nil); err != nil {
		t.Fatal(err)
	}
	if local.R.Type == nil {
		t.Error("struct should have been eager loaded")
	}

	local.R.Type = nil
	if err = local.L.LoadType(ctx, tx, true, &local, nil); err != nil {
		t.Fatal(err)
	}
	if local.R.Type == nil {
		t.Error("struct should have been eager loaded")
	}
}

func testOrganizationalUnitToOneSetOpOrganizationalUnitUsingParent(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c OrganizationalUnit

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &b, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &c, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	for i, x := range []*OrganizationalUnit{&b, &c} {
		err = a.SetParent(ctx, tx, i != 0, x)
		if err != nil {
			t.Fatal(err)
		}

		if a.R.Parent != x {
			t.Error("relationship struct not set to correct value")
		}

		if x.R.ParentOrganizationalUnits[0] != &a {
			t.Error("failed to append to foreign relationship struct")
		}
		if !queries.Equal(a.ParentID, x.ID) {
			t.Error("foreign key was wrong value", a.ParentID)
		}

		zero := reflect.Zero(reflect.TypeOf(a.ParentID))
		reflect.Indirect(reflect.ValueOf(&a.ParentID)).Set(zero)

		if err = a.Reload(ctx, tx); err != nil {
			t.Fatal("failed to reload", err)
		}

		if !queries.Equal(a.ParentID, x.ID) {
			t.Error("foreign key was wrong value", a.ParentID, x.ID)
		}
	}
}

func testOrganizationalUnitToOneRemoveOpOrganizationalUnitUsingParent(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b OrganizationalUnit

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &b, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}

	if err = a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	if err = a.SetParent(ctx, tx, true, &b); err != nil {
		t.Fatal(err)
	}

	if err = a.RemoveParent(ctx, tx, &b); err != nil {
		t.Error("failed to remove relationship")
	}

	count, err := a.Parent().Count(ctx, tx)
	if err != nil {
		t.Error(err)
	}
	if count != 0 {
		t.Error("want no relationships remaining")
	}

	if a.R.Parent != nil {
		t.Error("R struct entry should be nil")
	}

	if !queries.IsValuerNil(a.ParentID) {
		t.Error("foreign key value should be nil")
	}

	if len(b.R.ParentOrganizationalUnits) != 0 {
		t.Error("failed to remove a from b's relationships")
	}
}

func testOrganizationalUnitToOneSetOpOrganizationalUnitTypeUsingType(t *testing.T) {
	var err error

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()

	var a OrganizationalUnit
	var b, c OrganizationalUnitType

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, organizationalUnitDBTypes, false, strmangle.SetComplement(organizationalUnitPrimaryKeyColumns, organizationalUnitColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &b, organizationalUnitTypeDBTypes, false, strmangle.SetComplement(organizationalUnitTypePrimaryKeyColumns, organizationalUnitTypeColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &c, organizationalUnitTypeDBTypes, false, strmangle.SetComplement(organizationalUnitTypePrimaryKeyColumns, organizationalUnitTypeColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}

	if err := a.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Fatal(err)
	}

	for i, x := range []*OrganizationalUnitType{&b, &c} {
		err = a.SetType(ctx, tx, i != 0, x)
		if err != nil {
			t.Fatal(err)
		}

		if a.R.Type != x {
			t.Error("relationship struct not set to correct value")
		}

		if x.R.TypeOrganizationalUnits[0] != &a {
			t.Error("failed to append to foreign relationship struct")
		}
		if a.TypeID != x.ID {
			t.Error("foreign key was wrong value", a.TypeID)
		}

		zero := reflect.Zero(reflect.TypeOf(a.TypeID))
		reflect.Indirect(reflect.ValueOf(&a.TypeID)).Set(zero)

		if err = a.Reload(ctx, tx); err != nil {
			t.Fatal("failed to reload", err)
		}

		if a.TypeID != x.ID {
			t.Error("foreign key was wrong value", a.TypeID, x.ID)
		}
	}
}

func testOrganizationalUnitsReload(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	o := &OrganizationalUnit{}
	if err = randomize.Struct(seed, o, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()
	if err = o.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	}

	if err = o.Reload(ctx, tx); err != nil {
		t.Error(err)
	}
}

func testOrganizationalUnitsReloadAll(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	o := &OrganizationalUnit{}
	if err = randomize.Struct(seed, o, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()
	if err = o.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	}

	slice := OrganizationalUnitSlice{o}

	if err = slice.ReloadAll(ctx, tx); err != nil {
		t.Error(err)
	}
}

func testOrganizationalUnitsSelect(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	o := &OrganizationalUnit{}
	if err = randomize.Struct(seed, o, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()
	if err = o.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	}

	slice, err := OrganizationalUnits().All(ctx, tx)
	if err != nil {
		t.Error(err)
	}

	if len(slice) != 1 {
		t.Error("want one record, got:", len(slice))
	}
}

var (
	organizationalUnitDBTypes = map[string]string{`ID`: `uuid`, `DisplayName`: `character varying`, `CreatedAt`: `timestamp with time zone`, `DeletedAt`: `timestamp with time zone`, `ParentID`: `uuid`, `Metadata`: `jsonb`, `TypeID`: `uuid`}
	_                         = bytes.MinRead
)

func testOrganizationalUnitsUpdate(t *testing.T) {
	t.Parallel()

	if 0 == len(organizationalUnitPrimaryKeyColumns) {
		t.Skip("Skipping table with no primary key columns")
	}
	if len(organizationalUnitAllColumns) == len(organizationalUnitPrimaryKeyColumns) {
		t.Skip("Skipping table with only primary key columns")
	}

	seed := randomize.NewSeed()
	var err error
	o := &OrganizationalUnit{}
	if err = randomize.Struct(seed, o, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()
	if err = o.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	}

	count, err := OrganizationalUnits().Count(ctx, tx)
	if err != nil {
		t.Error(err)
	}

	if count != 1 {
		t.Error("want one record, got:", count)
	}

	if err = randomize.Struct(seed, o, organizationalUnitDBTypes, true, organizationalUnitPrimaryKeyColumns...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	if rowsAff, err := o.Update(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	} else if rowsAff != 1 {
		t.Error("should only affect one row but affected", rowsAff)
	}
}

func testOrganizationalUnitsSliceUpdateAll(t *testing.T) {
	t.Parallel()

	if len(organizationalUnitAllColumns) == len(organizationalUnitPrimaryKeyColumns) {
		t.Skip("Skipping table with only primary key columns")
	}

	seed := randomize.NewSeed()
	var err error
	o := &OrganizationalUnit{}
	if err = randomize.Struct(seed, o, organizationalUnitDBTypes, true, organizationalUnitColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()
	if err = o.Insert(ctx, tx, boil.Infer()); err != nil {
		t.Error(err)
	}

	count, err := OrganizationalUnits().Count(ctx, tx)
	if err != nil {
		t.Error(err)
	}

	if count != 1 {
		t.Error("want one record, got:", count)
	}

	if err = randomize.Struct(seed, o, organizationalUnitDBTypes, true, organizationalUnitPrimaryKeyColumns...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	// Remove Primary keys and unique columns from what we plan to update
	var fields []string
	if strmangle.StringSliceMatch(organizationalUnitAllColumns, organizationalUnitPrimaryKeyColumns) {
		fields = organizationalUnitAllColumns
	} else {
		fields = strmangle.SetComplement(
			organizationalUnitAllColumns,
			organizationalUnitPrimaryKeyColumns,
		)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	typ := reflect.TypeOf(o).Elem()
	n := typ.NumField()

	updateMap := M{}
	for _, col := range fields {
		for i := 0; i < n; i++ {
			f := typ.Field(i)
			if f.Tag.Get("boil") == col {
				updateMap[col] = value.Field(i).Interface()
			}
		}
	}

	slice := OrganizationalUnitSlice{o}
	if rowsAff, err := slice.UpdateAll(ctx, tx, updateMap); err != nil {
		t.Error(err)
	} else if rowsAff != 1 {
		t.Error("wanted one record updated but got", rowsAff)
	}
}

func testOrganizationalUnitsUpsert(t *testing.T) {
	t.Parallel()

	if len(organizationalUnitAllColumns) == len(organizationalUnitPrimaryKeyColumns) {
		t.Skip("Skipping table with only primary key columns")
	}

	seed := randomize.NewSeed()
	var err error
	// Attempt the INSERT side of an UPSERT
	o := OrganizationalUnit{}
	if err = randomize.Struct(seed, &o, organizationalUnitDBTypes, true); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	ctx := context.Background()
	tx := MustTx(boil.BeginTx(ctx, nil))
	defer func() { _ = tx.Rollback() }()
	if err = o.Upsert(ctx, tx, false, nil, boil.Infer(), boil.Infer()); err != nil {
		t.Errorf("Unable to upsert OrganizationalUnit: %s", err)
	}

	count, err := OrganizationalUnits().Count(ctx, tx)
	if err != nil {
		t.Error(err)
	}
	if count != 1 {
		t.Error("want one record, got:", count)
	}

	// Attempt the UPDATE side of an UPSERT
	if err = randomize.Struct(seed, &o, organizationalUnitDBTypes, false, organizationalUnitPrimaryKeyColumns...); err != nil {
		t.Errorf("Unable to randomize OrganizationalUnit struct: %s", err)
	}

	if err = o.Upsert(ctx, tx, true, nil, boil.Infer(), boil.Infer()); err != nil {
		t.Errorf("Unable to upsert OrganizationalUnit: %s", err)
	}

	count, err = OrganizationalUnits().Count(ctx, tx)
	if err != nil {
		t.Error(err)
	}
	if count != 1 {
		t.Error("want one record, got:", count)
	}
}
