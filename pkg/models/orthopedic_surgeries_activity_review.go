// Code generated by SQLBoiler 4.8.3 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// OrthopedicSurgeriesActivityReview is an object representing the database table.
type OrthopedicSurgeriesActivityReview struct {
	ID                          string     `boil:"id" json:"id" toml:"id" yaml:"id"`
	OrthopedicSurgeryActivityID string     `boil:"orthopedic_surgery_activity_id" json:"orthopedic_surgery_activity_id" toml:"orthopedic_surgery_activity_id" yaml:"orthopedic_surgery_activity_id"`
	CreatedAt                   time.Time  `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt                   null.Time  `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	SignedAt                    null.Time  `boil:"signed_at" json:"signed_at,omitempty" toml:"signed_at" yaml:"signed_at,omitempty"`
	OccurredAt                  time.Time  `boil:"occurred_at" json:"occurred_at" toml:"occurred_at" yaml:"occurred_at"`
	CaseNotes                   string     `boil:"case_notes" json:"case_notes" toml:"case_notes" yaml:"case_notes"`
	PatientAge                  int        `boil:"patient_age" json:"patient_age" toml:"patient_age" yaml:"patient_age"`
	PatientGender               string     `boil:"patient_gender" json:"patient_gender" toml:"patient_gender" yaml:"patient_gender"`
	Annotations                 types.JSON `boil:"annotations" json:"annotations" toml:"annotations" yaml:"annotations"`
	ResidentID                  string     `boil:"resident_id" json:"resident_id" toml:"resident_id" yaml:"resident_id"`
	SupervisorID                string     `boil:"supervisor_id" json:"supervisor_id" toml:"supervisor_id" yaml:"supervisor_id"`
	OperatorID                  string     `boil:"operator_id" json:"operator_id" toml:"operator_id" yaml:"operator_id"`
	AssistantID                 string     `boil:"assistant_id" json:"assistant_id" toml:"assistant_id" yaml:"assistant_id"`
	Comments                    string     `boil:"comments" json:"comments" toml:"comments" yaml:"comments"`
	Complications               string     `boil:"complications" json:"complications" toml:"complications" yaml:"complications"`
	ReviewComment               string     `boil:"review_comment" json:"review_comment" toml:"review_comment" yaml:"review_comment"`
	Requested                   bool       `boil:"requested" json:"requested" toml:"requested" yaml:"requested"`
	InProgress                  bool       `boil:"in_progress" json:"in_progress" toml:"in_progress" yaml:"in_progress"`
	ActiveStep                  int        `boil:"active_step" json:"active_step" toml:"active_step" yaml:"active_step"`
	CompletedStep               int        `boil:"completed_step" json:"completed_step" toml:"completed_step" yaml:"completed_step"`

	R *orthopedicSurgeriesActivityReviewR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L orthopedicSurgeriesActivityReviewL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var OrthopedicSurgeriesActivityReviewColumns = struct {
	ID                          string
	OrthopedicSurgeryActivityID string
	CreatedAt                   string
	UpdatedAt                   string
	SignedAt                    string
	OccurredAt                  string
	CaseNotes                   string
	PatientAge                  string
	PatientGender               string
	Annotations                 string
	ResidentID                  string
	SupervisorID                string
	OperatorID                  string
	AssistantID                 string
	Comments                    string
	Complications               string
	ReviewComment               string
	Requested                   string
	InProgress                  string
	ActiveStep                  string
	CompletedStep               string
}{
	ID:                          "id",
	OrthopedicSurgeryActivityID: "orthopedic_surgery_activity_id",
	CreatedAt:                   "created_at",
	UpdatedAt:                   "updated_at",
	SignedAt:                    "signed_at",
	OccurredAt:                  "occurred_at",
	CaseNotes:                   "case_notes",
	PatientAge:                  "patient_age",
	PatientGender:               "patient_gender",
	Annotations:                 "annotations",
	ResidentID:                  "resident_id",
	SupervisorID:                "supervisor_id",
	OperatorID:                  "operator_id",
	AssistantID:                 "assistant_id",
	Comments:                    "comments",
	Complications:               "complications",
	ReviewComment:               "review_comment",
	Requested:                   "requested",
	InProgress:                  "in_progress",
	ActiveStep:                  "active_step",
	CompletedStep:               "completed_step",
}

var OrthopedicSurgeriesActivityReviewTableColumns = struct {
	ID                          string
	OrthopedicSurgeryActivityID string
	CreatedAt                   string
	UpdatedAt                   string
	SignedAt                    string
	OccurredAt                  string
	CaseNotes                   string
	PatientAge                  string
	PatientGender               string
	Annotations                 string
	ResidentID                  string
	SupervisorID                string
	OperatorID                  string
	AssistantID                 string
	Comments                    string
	Complications               string
	ReviewComment               string
	Requested                   string
	InProgress                  string
	ActiveStep                  string
	CompletedStep               string
}{
	ID:                          "orthopedic_surgeries_activity_review.id",
	OrthopedicSurgeryActivityID: "orthopedic_surgeries_activity_review.orthopedic_surgery_activity_id",
	CreatedAt:                   "orthopedic_surgeries_activity_review.created_at",
	UpdatedAt:                   "orthopedic_surgeries_activity_review.updated_at",
	SignedAt:                    "orthopedic_surgeries_activity_review.signed_at",
	OccurredAt:                  "orthopedic_surgeries_activity_review.occurred_at",
	CaseNotes:                   "orthopedic_surgeries_activity_review.case_notes",
	PatientAge:                  "orthopedic_surgeries_activity_review.patient_age",
	PatientGender:               "orthopedic_surgeries_activity_review.patient_gender",
	Annotations:                 "orthopedic_surgeries_activity_review.annotations",
	ResidentID:                  "orthopedic_surgeries_activity_review.resident_id",
	SupervisorID:                "orthopedic_surgeries_activity_review.supervisor_id",
	OperatorID:                  "orthopedic_surgeries_activity_review.operator_id",
	AssistantID:                 "orthopedic_surgeries_activity_review.assistant_id",
	Comments:                    "orthopedic_surgeries_activity_review.comments",
	Complications:               "orthopedic_surgeries_activity_review.complications",
	ReviewComment:               "orthopedic_surgeries_activity_review.review_comment",
	Requested:                   "orthopedic_surgeries_activity_review.requested",
	InProgress:                  "orthopedic_surgeries_activity_review.in_progress",
	ActiveStep:                  "orthopedic_surgeries_activity_review.active_step",
	CompletedStep:               "orthopedic_surgeries_activity_review.completed_step",
}

// Generated where

var OrthopedicSurgeriesActivityReviewWhere = struct {
	ID                          whereHelperstring
	OrthopedicSurgeryActivityID whereHelperstring
	CreatedAt                   whereHelpertime_Time
	UpdatedAt                   whereHelpernull_Time
	SignedAt                    whereHelpernull_Time
	OccurredAt                  whereHelpertime_Time
	CaseNotes                   whereHelperstring
	PatientAge                  whereHelperint
	PatientGender               whereHelperstring
	Annotations                 whereHelpertypes_JSON
	ResidentID                  whereHelperstring
	SupervisorID                whereHelperstring
	OperatorID                  whereHelperstring
	AssistantID                 whereHelperstring
	Comments                    whereHelperstring
	Complications               whereHelperstring
	ReviewComment               whereHelperstring
	Requested                   whereHelperbool
	InProgress                  whereHelperbool
	ActiveStep                  whereHelperint
	CompletedStep               whereHelperint
}{
	ID:                          whereHelperstring{field: "\"orthopedic_surgeries_activity_review\".\"id\""},
	OrthopedicSurgeryActivityID: whereHelperstring{field: "\"orthopedic_surgeries_activity_review\".\"orthopedic_surgery_activity_id\""},
	CreatedAt:                   whereHelpertime_Time{field: "\"orthopedic_surgeries_activity_review\".\"created_at\""},
	UpdatedAt:                   whereHelpernull_Time{field: "\"orthopedic_surgeries_activity_review\".\"updated_at\""},
	SignedAt:                    whereHelpernull_Time{field: "\"orthopedic_surgeries_activity_review\".\"signed_at\""},
	OccurredAt:                  whereHelpertime_Time{field: "\"orthopedic_surgeries_activity_review\".\"occurred_at\""},
	CaseNotes:                   whereHelperstring{field: "\"orthopedic_surgeries_activity_review\".\"case_notes\""},
	PatientAge:                  whereHelperint{field: "\"orthopedic_surgeries_activity_review\".\"patient_age\""},
	PatientGender:               whereHelperstring{field: "\"orthopedic_surgeries_activity_review\".\"patient_gender\""},
	Annotations:                 whereHelpertypes_JSON{field: "\"orthopedic_surgeries_activity_review\".\"annotations\""},
	ResidentID:                  whereHelperstring{field: "\"orthopedic_surgeries_activity_review\".\"resident_id\""},
	SupervisorID:                whereHelperstring{field: "\"orthopedic_surgeries_activity_review\".\"supervisor_id\""},
	OperatorID:                  whereHelperstring{field: "\"orthopedic_surgeries_activity_review\".\"operator_id\""},
	AssistantID:                 whereHelperstring{field: "\"orthopedic_surgeries_activity_review\".\"assistant_id\""},
	Comments:                    whereHelperstring{field: "\"orthopedic_surgeries_activity_review\".\"comments\""},
	Complications:               whereHelperstring{field: "\"orthopedic_surgeries_activity_review\".\"complications\""},
	ReviewComment:               whereHelperstring{field: "\"orthopedic_surgeries_activity_review\".\"review_comment\""},
	Requested:                   whereHelperbool{field: "\"orthopedic_surgeries_activity_review\".\"requested\""},
	InProgress:                  whereHelperbool{field: "\"orthopedic_surgeries_activity_review\".\"in_progress\""},
	ActiveStep:                  whereHelperint{field: "\"orthopedic_surgeries_activity_review\".\"active_step\""},
	CompletedStep:               whereHelperint{field: "\"orthopedic_surgeries_activity_review\".\"completed_step\""},
}

// OrthopedicSurgeriesActivityReviewRels is where relationship names are stored.
var OrthopedicSurgeriesActivityReviewRels = struct {
	OrthopedicSurgeryActivity                  string
	Assistant                                  string
	Operator                                   string
	Resident                                   string
	Supervisor                                 string
	OrthopedicSurgeryReviewAssessment          string
	OrthopedicSurgeriesActivityReviewSurgeries string
}{
	OrthopedicSurgeryActivity:         "OrthopedicSurgeryActivity",
	Assistant:                         "Assistant",
	Operator:                          "Operator",
	Resident:                          "Resident",
	Supervisor:                        "Supervisor",
	OrthopedicSurgeryReviewAssessment: "OrthopedicSurgeryReviewAssessment",
	OrthopedicSurgeriesActivityReviewSurgeries: "OrthopedicSurgeriesActivityReviewSurgeries",
}

// orthopedicSurgeriesActivityReviewR is where relationships are stored.
type orthopedicSurgeriesActivityReviewR struct {
	OrthopedicSurgeryActivity                  *OrthopedicSurgeryActivity                    `boil:"OrthopedicSurgeryActivity" json:"OrthopedicSurgeryActivity" toml:"OrthopedicSurgeryActivity" yaml:"OrthopedicSurgeryActivity"`
	Assistant                                  *User                                         `boil:"Assistant" json:"Assistant" toml:"Assistant" yaml:"Assistant"`
	Operator                                   *User                                         `boil:"Operator" json:"Operator" toml:"Operator" yaml:"Operator"`
	Resident                                   *User                                         `boil:"Resident" json:"Resident" toml:"Resident" yaml:"Resident"`
	Supervisor                                 *User                                         `boil:"Supervisor" json:"Supervisor" toml:"Supervisor" yaml:"Supervisor"`
	OrthopedicSurgeryReviewAssessment          *Assessment                                   `boil:"OrthopedicSurgeryReviewAssessment" json:"OrthopedicSurgeryReviewAssessment" toml:"OrthopedicSurgeryReviewAssessment" yaml:"OrthopedicSurgeryReviewAssessment"`
	OrthopedicSurgeriesActivityReviewSurgeries OrthopedicSurgeriesActivityReviewSurgerySlice `boil:"OrthopedicSurgeriesActivityReviewSurgeries" json:"OrthopedicSurgeriesActivityReviewSurgeries" toml:"OrthopedicSurgeriesActivityReviewSurgeries" yaml:"OrthopedicSurgeriesActivityReviewSurgeries"`
}

// NewStruct creates a new relationship struct
func (*orthopedicSurgeriesActivityReviewR) NewStruct() *orthopedicSurgeriesActivityReviewR {
	return &orthopedicSurgeriesActivityReviewR{}
}

// orthopedicSurgeriesActivityReviewL is where Load methods for each relationship are stored.
type orthopedicSurgeriesActivityReviewL struct{}

var (
	orthopedicSurgeriesActivityReviewAllColumns            = []string{"id", "orthopedic_surgery_activity_id", "created_at", "updated_at", "signed_at", "occurred_at", "case_notes", "patient_age", "patient_gender", "annotations", "resident_id", "supervisor_id", "operator_id", "assistant_id", "comments", "complications", "review_comment", "requested", "in_progress", "active_step", "completed_step"}
	orthopedicSurgeriesActivityReviewColumnsWithoutDefault = []string{"orthopedic_surgery_activity_id", "updated_at", "signed_at", "occurred_at", "case_notes", "patient_age", "patient_gender", "resident_id", "supervisor_id", "operator_id", "assistant_id"}
	orthopedicSurgeriesActivityReviewColumnsWithDefault    = []string{"id", "created_at", "annotations", "comments", "complications", "review_comment", "requested", "in_progress", "active_step", "completed_step"}
	orthopedicSurgeriesActivityReviewPrimaryKeyColumns     = []string{"id"}
)

type (
	// OrthopedicSurgeriesActivityReviewSlice is an alias for a slice of pointers to OrthopedicSurgeriesActivityReview.
	// This should almost always be used instead of []OrthopedicSurgeriesActivityReview.
	OrthopedicSurgeriesActivityReviewSlice []*OrthopedicSurgeriesActivityReview
	// OrthopedicSurgeriesActivityReviewHook is the signature for custom OrthopedicSurgeriesActivityReview hook methods
	OrthopedicSurgeriesActivityReviewHook func(context.Context, boil.ContextExecutor, *OrthopedicSurgeriesActivityReview) error

	orthopedicSurgeriesActivityReviewQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	orthopedicSurgeriesActivityReviewType                 = reflect.TypeOf(&OrthopedicSurgeriesActivityReview{})
	orthopedicSurgeriesActivityReviewMapping              = queries.MakeStructMapping(orthopedicSurgeriesActivityReviewType)
	orthopedicSurgeriesActivityReviewPrimaryKeyMapping, _ = queries.BindMapping(orthopedicSurgeriesActivityReviewType, orthopedicSurgeriesActivityReviewMapping, orthopedicSurgeriesActivityReviewPrimaryKeyColumns)
	orthopedicSurgeriesActivityReviewInsertCacheMut       sync.RWMutex
	orthopedicSurgeriesActivityReviewInsertCache          = make(map[string]insertCache)
	orthopedicSurgeriesActivityReviewUpdateCacheMut       sync.RWMutex
	orthopedicSurgeriesActivityReviewUpdateCache          = make(map[string]updateCache)
	orthopedicSurgeriesActivityReviewUpsertCacheMut       sync.RWMutex
	orthopedicSurgeriesActivityReviewUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var orthopedicSurgeriesActivityReviewBeforeInsertHooks []OrthopedicSurgeriesActivityReviewHook
var orthopedicSurgeriesActivityReviewBeforeUpdateHooks []OrthopedicSurgeriesActivityReviewHook
var orthopedicSurgeriesActivityReviewBeforeDeleteHooks []OrthopedicSurgeriesActivityReviewHook
var orthopedicSurgeriesActivityReviewBeforeUpsertHooks []OrthopedicSurgeriesActivityReviewHook

var orthopedicSurgeriesActivityReviewAfterInsertHooks []OrthopedicSurgeriesActivityReviewHook
var orthopedicSurgeriesActivityReviewAfterSelectHooks []OrthopedicSurgeriesActivityReviewHook
var orthopedicSurgeriesActivityReviewAfterUpdateHooks []OrthopedicSurgeriesActivityReviewHook
var orthopedicSurgeriesActivityReviewAfterDeleteHooks []OrthopedicSurgeriesActivityReviewHook
var orthopedicSurgeriesActivityReviewAfterUpsertHooks []OrthopedicSurgeriesActivityReviewHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *OrthopedicSurgeriesActivityReview) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeriesActivityReviewBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *OrthopedicSurgeriesActivityReview) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeriesActivityReviewBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *OrthopedicSurgeriesActivityReview) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeriesActivityReviewBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *OrthopedicSurgeriesActivityReview) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeriesActivityReviewBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *OrthopedicSurgeriesActivityReview) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeriesActivityReviewAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *OrthopedicSurgeriesActivityReview) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeriesActivityReviewAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *OrthopedicSurgeriesActivityReview) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeriesActivityReviewAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *OrthopedicSurgeriesActivityReview) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeriesActivityReviewAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *OrthopedicSurgeriesActivityReview) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orthopedicSurgeriesActivityReviewAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddOrthopedicSurgeriesActivityReviewHook registers your hook function for all future operations.
func AddOrthopedicSurgeriesActivityReviewHook(hookPoint boil.HookPoint, orthopedicSurgeriesActivityReviewHook OrthopedicSurgeriesActivityReviewHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		orthopedicSurgeriesActivityReviewBeforeInsertHooks = append(orthopedicSurgeriesActivityReviewBeforeInsertHooks, orthopedicSurgeriesActivityReviewHook)
	case boil.BeforeUpdateHook:
		orthopedicSurgeriesActivityReviewBeforeUpdateHooks = append(orthopedicSurgeriesActivityReviewBeforeUpdateHooks, orthopedicSurgeriesActivityReviewHook)
	case boil.BeforeDeleteHook:
		orthopedicSurgeriesActivityReviewBeforeDeleteHooks = append(orthopedicSurgeriesActivityReviewBeforeDeleteHooks, orthopedicSurgeriesActivityReviewHook)
	case boil.BeforeUpsertHook:
		orthopedicSurgeriesActivityReviewBeforeUpsertHooks = append(orthopedicSurgeriesActivityReviewBeforeUpsertHooks, orthopedicSurgeriesActivityReviewHook)
	case boil.AfterInsertHook:
		orthopedicSurgeriesActivityReviewAfterInsertHooks = append(orthopedicSurgeriesActivityReviewAfterInsertHooks, orthopedicSurgeriesActivityReviewHook)
	case boil.AfterSelectHook:
		orthopedicSurgeriesActivityReviewAfterSelectHooks = append(orthopedicSurgeriesActivityReviewAfterSelectHooks, orthopedicSurgeriesActivityReviewHook)
	case boil.AfterUpdateHook:
		orthopedicSurgeriesActivityReviewAfterUpdateHooks = append(orthopedicSurgeriesActivityReviewAfterUpdateHooks, orthopedicSurgeriesActivityReviewHook)
	case boil.AfterDeleteHook:
		orthopedicSurgeriesActivityReviewAfterDeleteHooks = append(orthopedicSurgeriesActivityReviewAfterDeleteHooks, orthopedicSurgeriesActivityReviewHook)
	case boil.AfterUpsertHook:
		orthopedicSurgeriesActivityReviewAfterUpsertHooks = append(orthopedicSurgeriesActivityReviewAfterUpsertHooks, orthopedicSurgeriesActivityReviewHook)
	}
}

// One returns a single orthopedicSurgeriesActivityReview record from the query.
func (q orthopedicSurgeriesActivityReviewQuery) One(ctx context.Context, exec boil.ContextExecutor) (*OrthopedicSurgeriesActivityReview, error) {
	o := &OrthopedicSurgeriesActivityReview{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for orthopedic_surgeries_activity_review")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all OrthopedicSurgeriesActivityReview records from the query.
func (q orthopedicSurgeriesActivityReviewQuery) All(ctx context.Context, exec boil.ContextExecutor) (OrthopedicSurgeriesActivityReviewSlice, error) {
	var o []*OrthopedicSurgeriesActivityReview

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to OrthopedicSurgeriesActivityReview slice")
	}

	if len(orthopedicSurgeriesActivityReviewAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all OrthopedicSurgeriesActivityReview records in the query.
func (q orthopedicSurgeriesActivityReviewQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count orthopedic_surgeries_activity_review rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q orthopedicSurgeriesActivityReviewQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if orthopedic_surgeries_activity_review exists")
	}

	return count > 0, nil
}

// OrthopedicSurgeryActivity pointed to by the foreign key.
func (o *OrthopedicSurgeriesActivityReview) OrthopedicSurgeryActivity(mods ...qm.QueryMod) orthopedicSurgeryActivityQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.OrthopedicSurgeryActivityID),
	}

	queryMods = append(queryMods, mods...)

	query := OrthopedicSurgeryActivities(queryMods...)
	queries.SetFrom(query.Query, "\"orthopedic_surgery_activities\"")

	return query
}

// Assistant pointed to by the foreign key.
func (o *OrthopedicSurgeriesActivityReview) Assistant(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.AssistantID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	return query
}

// Operator pointed to by the foreign key.
func (o *OrthopedicSurgeriesActivityReview) Operator(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.OperatorID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	return query
}

// Resident pointed to by the foreign key.
func (o *OrthopedicSurgeriesActivityReview) Resident(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ResidentID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	return query
}

// Supervisor pointed to by the foreign key.
func (o *OrthopedicSurgeriesActivityReview) Supervisor(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.SupervisorID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	return query
}

// OrthopedicSurgeryReviewAssessment pointed to by the foreign key.
func (o *OrthopedicSurgeriesActivityReview) OrthopedicSurgeryReviewAssessment(mods ...qm.QueryMod) assessmentQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"orthopedic_surgery_review_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	query := Assessments(queryMods...)
	queries.SetFrom(query.Query, "\"assessments\"")

	return query
}

// OrthopedicSurgeriesActivityReviewSurgeries retrieves all the orthopedic_surgeries_activity_review_surgery's OrthopedicSurgeriesActivityReviewSurgeries with an executor.
func (o *OrthopedicSurgeriesActivityReview) OrthopedicSurgeriesActivityReviewSurgeries(mods ...qm.QueryMod) orthopedicSurgeriesActivityReviewSurgeryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"orthopedic_surgeries_activity_review_surgeries\".\"orthopedic_surgeries_activity_review_id\"=?", o.ID),
	)

	query := OrthopedicSurgeriesActivityReviewSurgeries(queryMods...)
	queries.SetFrom(query.Query, "\"orthopedic_surgeries_activity_review_surgeries\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"orthopedic_surgeries_activity_review_surgeries\".*"})
	}

	return query
}

// LoadOrthopedicSurgeryActivity allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (orthopedicSurgeriesActivityReviewL) LoadOrthopedicSurgeryActivity(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrthopedicSurgeriesActivityReview interface{}, mods queries.Applicator) error {
	var slice []*OrthopedicSurgeriesActivityReview
	var object *OrthopedicSurgeriesActivityReview

	if singular {
		object = maybeOrthopedicSurgeriesActivityReview.(*OrthopedicSurgeriesActivityReview)
	} else {
		slice = *maybeOrthopedicSurgeriesActivityReview.(*[]*OrthopedicSurgeriesActivityReview)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orthopedicSurgeriesActivityReviewR{}
		}
		args = append(args, object.OrthopedicSurgeryActivityID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orthopedicSurgeriesActivityReviewR{}
			}

			for _, a := range args {
				if a == obj.OrthopedicSurgeryActivityID {
					continue Outer
				}
			}

			args = append(args, obj.OrthopedicSurgeryActivityID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`orthopedic_surgery_activities`),
		qm.WhereIn(`orthopedic_surgery_activities.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load OrthopedicSurgeryActivity")
	}

	var resultSlice []*OrthopedicSurgeryActivity
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice OrthopedicSurgeryActivity")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for orthopedic_surgery_activities")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for orthopedic_surgery_activities")
	}

	if len(orthopedicSurgeriesActivityReviewAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.OrthopedicSurgeryActivity = foreign
		if foreign.R == nil {
			foreign.R = &orthopedicSurgeryActivityR{}
		}
		foreign.R.OrthopedicSurgeriesActivityReview = object
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.OrthopedicSurgeryActivityID == foreign.ID {
				local.R.OrthopedicSurgeryActivity = foreign
				if foreign.R == nil {
					foreign.R = &orthopedicSurgeryActivityR{}
				}
				foreign.R.OrthopedicSurgeriesActivityReview = local
				break
			}
		}
	}

	return nil
}

// LoadAssistant allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (orthopedicSurgeriesActivityReviewL) LoadAssistant(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrthopedicSurgeriesActivityReview interface{}, mods queries.Applicator) error {
	var slice []*OrthopedicSurgeriesActivityReview
	var object *OrthopedicSurgeriesActivityReview

	if singular {
		object = maybeOrthopedicSurgeriesActivityReview.(*OrthopedicSurgeriesActivityReview)
	} else {
		slice = *maybeOrthopedicSurgeriesActivityReview.(*[]*OrthopedicSurgeriesActivityReview)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orthopedicSurgeriesActivityReviewR{}
		}
		args = append(args, object.AssistantID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orthopedicSurgeriesActivityReviewR{}
			}

			for _, a := range args {
				if a == obj.AssistantID {
					continue Outer
				}
			}

			args = append(args, obj.AssistantID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(orthopedicSurgeriesActivityReviewAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Assistant = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.AssistantOrthopedicSurgeriesActivityReviews = append(foreign.R.AssistantOrthopedicSurgeriesActivityReviews, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.AssistantID == foreign.ID {
				local.R.Assistant = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.AssistantOrthopedicSurgeriesActivityReviews = append(foreign.R.AssistantOrthopedicSurgeriesActivityReviews, local)
				break
			}
		}
	}

	return nil
}

// LoadOperator allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (orthopedicSurgeriesActivityReviewL) LoadOperator(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrthopedicSurgeriesActivityReview interface{}, mods queries.Applicator) error {
	var slice []*OrthopedicSurgeriesActivityReview
	var object *OrthopedicSurgeriesActivityReview

	if singular {
		object = maybeOrthopedicSurgeriesActivityReview.(*OrthopedicSurgeriesActivityReview)
	} else {
		slice = *maybeOrthopedicSurgeriesActivityReview.(*[]*OrthopedicSurgeriesActivityReview)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orthopedicSurgeriesActivityReviewR{}
		}
		args = append(args, object.OperatorID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orthopedicSurgeriesActivityReviewR{}
			}

			for _, a := range args {
				if a == obj.OperatorID {
					continue Outer
				}
			}

			args = append(args, obj.OperatorID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(orthopedicSurgeriesActivityReviewAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Operator = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.OperatorOrthopedicSurgeriesActivityReviews = append(foreign.R.OperatorOrthopedicSurgeriesActivityReviews, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.OperatorID == foreign.ID {
				local.R.Operator = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.OperatorOrthopedicSurgeriesActivityReviews = append(foreign.R.OperatorOrthopedicSurgeriesActivityReviews, local)
				break
			}
		}
	}

	return nil
}

// LoadResident allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (orthopedicSurgeriesActivityReviewL) LoadResident(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrthopedicSurgeriesActivityReview interface{}, mods queries.Applicator) error {
	var slice []*OrthopedicSurgeriesActivityReview
	var object *OrthopedicSurgeriesActivityReview

	if singular {
		object = maybeOrthopedicSurgeriesActivityReview.(*OrthopedicSurgeriesActivityReview)
	} else {
		slice = *maybeOrthopedicSurgeriesActivityReview.(*[]*OrthopedicSurgeriesActivityReview)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orthopedicSurgeriesActivityReviewR{}
		}
		args = append(args, object.ResidentID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orthopedicSurgeriesActivityReviewR{}
			}

			for _, a := range args {
				if a == obj.ResidentID {
					continue Outer
				}
			}

			args = append(args, obj.ResidentID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(orthopedicSurgeriesActivityReviewAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Resident = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.ResidentOrthopedicSurgeriesActivityReviews = append(foreign.R.ResidentOrthopedicSurgeriesActivityReviews, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ResidentID == foreign.ID {
				local.R.Resident = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.ResidentOrthopedicSurgeriesActivityReviews = append(foreign.R.ResidentOrthopedicSurgeriesActivityReviews, local)
				break
			}
		}
	}

	return nil
}

// LoadSupervisor allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (orthopedicSurgeriesActivityReviewL) LoadSupervisor(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrthopedicSurgeriesActivityReview interface{}, mods queries.Applicator) error {
	var slice []*OrthopedicSurgeriesActivityReview
	var object *OrthopedicSurgeriesActivityReview

	if singular {
		object = maybeOrthopedicSurgeriesActivityReview.(*OrthopedicSurgeriesActivityReview)
	} else {
		slice = *maybeOrthopedicSurgeriesActivityReview.(*[]*OrthopedicSurgeriesActivityReview)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orthopedicSurgeriesActivityReviewR{}
		}
		args = append(args, object.SupervisorID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orthopedicSurgeriesActivityReviewR{}
			}

			for _, a := range args {
				if a == obj.SupervisorID {
					continue Outer
				}
			}

			args = append(args, obj.SupervisorID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(orthopedicSurgeriesActivityReviewAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Supervisor = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.SupervisorOrthopedicSurgeriesActivityReviews = append(foreign.R.SupervisorOrthopedicSurgeriesActivityReviews, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.SupervisorID == foreign.ID {
				local.R.Supervisor = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.SupervisorOrthopedicSurgeriesActivityReviews = append(foreign.R.SupervisorOrthopedicSurgeriesActivityReviews, local)
				break
			}
		}
	}

	return nil
}

// LoadOrthopedicSurgeryReviewAssessment allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (orthopedicSurgeriesActivityReviewL) LoadOrthopedicSurgeryReviewAssessment(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrthopedicSurgeriesActivityReview interface{}, mods queries.Applicator) error {
	var slice []*OrthopedicSurgeriesActivityReview
	var object *OrthopedicSurgeriesActivityReview

	if singular {
		object = maybeOrthopedicSurgeriesActivityReview.(*OrthopedicSurgeriesActivityReview)
	} else {
		slice = *maybeOrthopedicSurgeriesActivityReview.(*[]*OrthopedicSurgeriesActivityReview)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orthopedicSurgeriesActivityReviewR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orthopedicSurgeriesActivityReviewR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`assessments`),
		qm.WhereIn(`assessments.orthopedic_surgery_review_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Assessment")
	}

	var resultSlice []*Assessment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Assessment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for assessments")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for assessments")
	}

	if len(orthopedicSurgeriesActivityReviewAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.OrthopedicSurgeryReviewAssessment = foreign
		if foreign.R == nil {
			foreign.R = &assessmentR{}
		}
		foreign.R.OrthopedicSurgeryReview = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ID, foreign.OrthopedicSurgeryReviewID) {
				local.R.OrthopedicSurgeryReviewAssessment = foreign
				if foreign.R == nil {
					foreign.R = &assessmentR{}
				}
				foreign.R.OrthopedicSurgeryReview = local
				break
			}
		}
	}

	return nil
}

// LoadOrthopedicSurgeriesActivityReviewSurgeries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (orthopedicSurgeriesActivityReviewL) LoadOrthopedicSurgeriesActivityReviewSurgeries(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrthopedicSurgeriesActivityReview interface{}, mods queries.Applicator) error {
	var slice []*OrthopedicSurgeriesActivityReview
	var object *OrthopedicSurgeriesActivityReview

	if singular {
		object = maybeOrthopedicSurgeriesActivityReview.(*OrthopedicSurgeriesActivityReview)
	} else {
		slice = *maybeOrthopedicSurgeriesActivityReview.(*[]*OrthopedicSurgeriesActivityReview)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orthopedicSurgeriesActivityReviewR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orthopedicSurgeriesActivityReviewR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`orthopedic_surgeries_activity_review_surgeries`),
		qm.WhereIn(`orthopedic_surgeries_activity_review_surgeries.orthopedic_surgeries_activity_review_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load orthopedic_surgeries_activity_review_surgeries")
	}

	var resultSlice []*OrthopedicSurgeriesActivityReviewSurgery
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice orthopedic_surgeries_activity_review_surgeries")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on orthopedic_surgeries_activity_review_surgeries")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for orthopedic_surgeries_activity_review_surgeries")
	}

	if len(orthopedicSurgeriesActivityReviewSurgeryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OrthopedicSurgeriesActivityReviewSurgeries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &orthopedicSurgeriesActivityReviewSurgeryR{}
			}
			foreign.R.OrthopedicSurgeriesActivityReview = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OrthopedicSurgeriesActivityReviewID {
				local.R.OrthopedicSurgeriesActivityReviewSurgeries = append(local.R.OrthopedicSurgeriesActivityReviewSurgeries, foreign)
				if foreign.R == nil {
					foreign.R = &orthopedicSurgeriesActivityReviewSurgeryR{}
				}
				foreign.R.OrthopedicSurgeriesActivityReview = local
				break
			}
		}
	}

	return nil
}

// SetOrthopedicSurgeryActivity of the orthopedicSurgeriesActivityReview to the related item.
// Sets o.R.OrthopedicSurgeryActivity to related.
// Adds o to related.R.OrthopedicSurgeriesActivityReview.
func (o *OrthopedicSurgeriesActivityReview) SetOrthopedicSurgeryActivity(ctx context.Context, exec boil.ContextExecutor, insert bool, related *OrthopedicSurgeryActivity) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"orthopedic_surgeries_activity_review\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"orthopedic_surgery_activity_id"}),
		strmangle.WhereClause("\"", "\"", 2, orthopedicSurgeriesActivityReviewPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.OrthopedicSurgeryActivityID = related.ID
	if o.R == nil {
		o.R = &orthopedicSurgeriesActivityReviewR{
			OrthopedicSurgeryActivity: related,
		}
	} else {
		o.R.OrthopedicSurgeryActivity = related
	}

	if related.R == nil {
		related.R = &orthopedicSurgeryActivityR{
			OrthopedicSurgeriesActivityReview: o,
		}
	} else {
		related.R.OrthopedicSurgeriesActivityReview = o
	}

	return nil
}

// SetAssistant of the orthopedicSurgeriesActivityReview to the related item.
// Sets o.R.Assistant to related.
// Adds o to related.R.AssistantOrthopedicSurgeriesActivityReviews.
func (o *OrthopedicSurgeriesActivityReview) SetAssistant(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"orthopedic_surgeries_activity_review\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"assistant_id"}),
		strmangle.WhereClause("\"", "\"", 2, orthopedicSurgeriesActivityReviewPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.AssistantID = related.ID
	if o.R == nil {
		o.R = &orthopedicSurgeriesActivityReviewR{
			Assistant: related,
		}
	} else {
		o.R.Assistant = related
	}

	if related.R == nil {
		related.R = &userR{
			AssistantOrthopedicSurgeriesActivityReviews: OrthopedicSurgeriesActivityReviewSlice{o},
		}
	} else {
		related.R.AssistantOrthopedicSurgeriesActivityReviews = append(related.R.AssistantOrthopedicSurgeriesActivityReviews, o)
	}

	return nil
}

// SetOperator of the orthopedicSurgeriesActivityReview to the related item.
// Sets o.R.Operator to related.
// Adds o to related.R.OperatorOrthopedicSurgeriesActivityReviews.
func (o *OrthopedicSurgeriesActivityReview) SetOperator(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"orthopedic_surgeries_activity_review\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"operator_id"}),
		strmangle.WhereClause("\"", "\"", 2, orthopedicSurgeriesActivityReviewPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.OperatorID = related.ID
	if o.R == nil {
		o.R = &orthopedicSurgeriesActivityReviewR{
			Operator: related,
		}
	} else {
		o.R.Operator = related
	}

	if related.R == nil {
		related.R = &userR{
			OperatorOrthopedicSurgeriesActivityReviews: OrthopedicSurgeriesActivityReviewSlice{o},
		}
	} else {
		related.R.OperatorOrthopedicSurgeriesActivityReviews = append(related.R.OperatorOrthopedicSurgeriesActivityReviews, o)
	}

	return nil
}

// SetResident of the orthopedicSurgeriesActivityReview to the related item.
// Sets o.R.Resident to related.
// Adds o to related.R.ResidentOrthopedicSurgeriesActivityReviews.
func (o *OrthopedicSurgeriesActivityReview) SetResident(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"orthopedic_surgeries_activity_review\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"resident_id"}),
		strmangle.WhereClause("\"", "\"", 2, orthopedicSurgeriesActivityReviewPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ResidentID = related.ID
	if o.R == nil {
		o.R = &orthopedicSurgeriesActivityReviewR{
			Resident: related,
		}
	} else {
		o.R.Resident = related
	}

	if related.R == nil {
		related.R = &userR{
			ResidentOrthopedicSurgeriesActivityReviews: OrthopedicSurgeriesActivityReviewSlice{o},
		}
	} else {
		related.R.ResidentOrthopedicSurgeriesActivityReviews = append(related.R.ResidentOrthopedicSurgeriesActivityReviews, o)
	}

	return nil
}

// SetSupervisor of the orthopedicSurgeriesActivityReview to the related item.
// Sets o.R.Supervisor to related.
// Adds o to related.R.SupervisorOrthopedicSurgeriesActivityReviews.
func (o *OrthopedicSurgeriesActivityReview) SetSupervisor(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"orthopedic_surgeries_activity_review\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"supervisor_id"}),
		strmangle.WhereClause("\"", "\"", 2, orthopedicSurgeriesActivityReviewPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.SupervisorID = related.ID
	if o.R == nil {
		o.R = &orthopedicSurgeriesActivityReviewR{
			Supervisor: related,
		}
	} else {
		o.R.Supervisor = related
	}

	if related.R == nil {
		related.R = &userR{
			SupervisorOrthopedicSurgeriesActivityReviews: OrthopedicSurgeriesActivityReviewSlice{o},
		}
	} else {
		related.R.SupervisorOrthopedicSurgeriesActivityReviews = append(related.R.SupervisorOrthopedicSurgeriesActivityReviews, o)
	}

	return nil
}

// SetOrthopedicSurgeryReviewAssessment of the orthopedicSurgeriesActivityReview to the related item.
// Sets o.R.OrthopedicSurgeryReviewAssessment to related.
// Adds o to related.R.OrthopedicSurgeryReview.
func (o *OrthopedicSurgeriesActivityReview) SetOrthopedicSurgeryReviewAssessment(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Assessment) error {
	var err error

	if insert {
		queries.Assign(&related.OrthopedicSurgeryReviewID, o.ID)

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"assessments\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"orthopedic_surgery_review_id"}),
			strmangle.WhereClause("\"", "\"", 2, assessmentPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.OrthopedicSurgeryReviewID, o.ID)
	}

	if o.R == nil {
		o.R = &orthopedicSurgeriesActivityReviewR{
			OrthopedicSurgeryReviewAssessment: related,
		}
	} else {
		o.R.OrthopedicSurgeryReviewAssessment = related
	}

	if related.R == nil {
		related.R = &assessmentR{
			OrthopedicSurgeryReview: o,
		}
	} else {
		related.R.OrthopedicSurgeryReview = o
	}
	return nil
}

// RemoveOrthopedicSurgeryReviewAssessment relationship.
// Sets o.R.OrthopedicSurgeryReviewAssessment to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *OrthopedicSurgeriesActivityReview) RemoveOrthopedicSurgeryReviewAssessment(ctx context.Context, exec boil.ContextExecutor, related *Assessment) error {
	var err error

	queries.SetScanner(&related.OrthopedicSurgeryReviewID, nil)
	if _, err = related.Update(ctx, exec, boil.Whitelist("orthopedic_surgery_review_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.OrthopedicSurgeryReviewAssessment = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	related.R.OrthopedicSurgeryReview = nil
	return nil
}

// AddOrthopedicSurgeriesActivityReviewSurgeries adds the given related objects to the existing relationships
// of the orthopedic_surgeries_activity_review, optionally inserting them as new records.
// Appends related to o.R.OrthopedicSurgeriesActivityReviewSurgeries.
// Sets related.R.OrthopedicSurgeriesActivityReview appropriately.
func (o *OrthopedicSurgeriesActivityReview) AddOrthopedicSurgeriesActivityReviewSurgeries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*OrthopedicSurgeriesActivityReviewSurgery) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OrthopedicSurgeriesActivityReviewID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"orthopedic_surgeries_activity_review_surgeries\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"orthopedic_surgeries_activity_review_id"}),
				strmangle.WhereClause("\"", "\"", 2, orthopedicSurgeriesActivityReviewSurgeryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OrthopedicSurgeriesActivityReviewID = o.ID
		}
	}

	if o.R == nil {
		o.R = &orthopedicSurgeriesActivityReviewR{
			OrthopedicSurgeriesActivityReviewSurgeries: related,
		}
	} else {
		o.R.OrthopedicSurgeriesActivityReviewSurgeries = append(o.R.OrthopedicSurgeriesActivityReviewSurgeries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &orthopedicSurgeriesActivityReviewSurgeryR{
				OrthopedicSurgeriesActivityReview: o,
			}
		} else {
			rel.R.OrthopedicSurgeriesActivityReview = o
		}
	}
	return nil
}

// OrthopedicSurgeriesActivityReviews retrieves all the records using an executor.
func OrthopedicSurgeriesActivityReviews(mods ...qm.QueryMod) orthopedicSurgeriesActivityReviewQuery {
	mods = append(mods, qm.From("\"orthopedic_surgeries_activity_review\""))
	return orthopedicSurgeriesActivityReviewQuery{NewQuery(mods...)}
}

// FindOrthopedicSurgeriesActivityReview retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindOrthopedicSurgeriesActivityReview(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*OrthopedicSurgeriesActivityReview, error) {
	orthopedicSurgeriesActivityReviewObj := &OrthopedicSurgeriesActivityReview{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"orthopedic_surgeries_activity_review\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, orthopedicSurgeriesActivityReviewObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from orthopedic_surgeries_activity_review")
	}

	if err = orthopedicSurgeriesActivityReviewObj.doAfterSelectHooks(ctx, exec); err != nil {
		return orthopedicSurgeriesActivityReviewObj, err
	}

	return orthopedicSurgeriesActivityReviewObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *OrthopedicSurgeriesActivityReview) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no orthopedic_surgeries_activity_review provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(orthopedicSurgeriesActivityReviewColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	orthopedicSurgeriesActivityReviewInsertCacheMut.RLock()
	cache, cached := orthopedicSurgeriesActivityReviewInsertCache[key]
	orthopedicSurgeriesActivityReviewInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			orthopedicSurgeriesActivityReviewAllColumns,
			orthopedicSurgeriesActivityReviewColumnsWithDefault,
			orthopedicSurgeriesActivityReviewColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(orthopedicSurgeriesActivityReviewType, orthopedicSurgeriesActivityReviewMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(orthopedicSurgeriesActivityReviewType, orthopedicSurgeriesActivityReviewMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"orthopedic_surgeries_activity_review\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"orthopedic_surgeries_activity_review\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into orthopedic_surgeries_activity_review")
	}

	if !cached {
		orthopedicSurgeriesActivityReviewInsertCacheMut.Lock()
		orthopedicSurgeriesActivityReviewInsertCache[key] = cache
		orthopedicSurgeriesActivityReviewInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the OrthopedicSurgeriesActivityReview.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *OrthopedicSurgeriesActivityReview) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	orthopedicSurgeriesActivityReviewUpdateCacheMut.RLock()
	cache, cached := orthopedicSurgeriesActivityReviewUpdateCache[key]
	orthopedicSurgeriesActivityReviewUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			orthopedicSurgeriesActivityReviewAllColumns,
			orthopedicSurgeriesActivityReviewPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update orthopedic_surgeries_activity_review, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"orthopedic_surgeries_activity_review\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, orthopedicSurgeriesActivityReviewPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(orthopedicSurgeriesActivityReviewType, orthopedicSurgeriesActivityReviewMapping, append(wl, orthopedicSurgeriesActivityReviewPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update orthopedic_surgeries_activity_review row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for orthopedic_surgeries_activity_review")
	}

	if !cached {
		orthopedicSurgeriesActivityReviewUpdateCacheMut.Lock()
		orthopedicSurgeriesActivityReviewUpdateCache[key] = cache
		orthopedicSurgeriesActivityReviewUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q orthopedicSurgeriesActivityReviewQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for orthopedic_surgeries_activity_review")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for orthopedic_surgeries_activity_review")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o OrthopedicSurgeriesActivityReviewSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), orthopedicSurgeriesActivityReviewPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"orthopedic_surgeries_activity_review\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, orthopedicSurgeriesActivityReviewPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in orthopedicSurgeriesActivityReview slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all orthopedicSurgeriesActivityReview")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *OrthopedicSurgeriesActivityReview) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no orthopedic_surgeries_activity_review provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(orthopedicSurgeriesActivityReviewColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	orthopedicSurgeriesActivityReviewUpsertCacheMut.RLock()
	cache, cached := orthopedicSurgeriesActivityReviewUpsertCache[key]
	orthopedicSurgeriesActivityReviewUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			orthopedicSurgeriesActivityReviewAllColumns,
			orthopedicSurgeriesActivityReviewColumnsWithDefault,
			orthopedicSurgeriesActivityReviewColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			orthopedicSurgeriesActivityReviewAllColumns,
			orthopedicSurgeriesActivityReviewPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert orthopedic_surgeries_activity_review, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(orthopedicSurgeriesActivityReviewPrimaryKeyColumns))
			copy(conflict, orthopedicSurgeriesActivityReviewPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"orthopedic_surgeries_activity_review\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(orthopedicSurgeriesActivityReviewType, orthopedicSurgeriesActivityReviewMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(orthopedicSurgeriesActivityReviewType, orthopedicSurgeriesActivityReviewMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert orthopedic_surgeries_activity_review")
	}

	if !cached {
		orthopedicSurgeriesActivityReviewUpsertCacheMut.Lock()
		orthopedicSurgeriesActivityReviewUpsertCache[key] = cache
		orthopedicSurgeriesActivityReviewUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single OrthopedicSurgeriesActivityReview record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *OrthopedicSurgeriesActivityReview) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no OrthopedicSurgeriesActivityReview provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), orthopedicSurgeriesActivityReviewPrimaryKeyMapping)
	sql := "DELETE FROM \"orthopedic_surgeries_activity_review\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from orthopedic_surgeries_activity_review")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for orthopedic_surgeries_activity_review")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q orthopedicSurgeriesActivityReviewQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no orthopedicSurgeriesActivityReviewQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from orthopedic_surgeries_activity_review")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for orthopedic_surgeries_activity_review")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o OrthopedicSurgeriesActivityReviewSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(orthopedicSurgeriesActivityReviewBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), orthopedicSurgeriesActivityReviewPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"orthopedic_surgeries_activity_review\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, orthopedicSurgeriesActivityReviewPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from orthopedicSurgeriesActivityReview slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for orthopedic_surgeries_activity_review")
	}

	if len(orthopedicSurgeriesActivityReviewAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *OrthopedicSurgeriesActivityReview) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindOrthopedicSurgeriesActivityReview(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *OrthopedicSurgeriesActivityReviewSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := OrthopedicSurgeriesActivityReviewSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), orthopedicSurgeriesActivityReviewPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"orthopedic_surgeries_activity_review\".* FROM \"orthopedic_surgeries_activity_review\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, orthopedicSurgeriesActivityReviewPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in OrthopedicSurgeriesActivityReviewSlice")
	}

	*o = slice

	return nil
}

// OrthopedicSurgeriesActivityReviewExists checks if the OrthopedicSurgeriesActivityReview row exists.
func OrthopedicSurgeriesActivityReviewExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"orthopedic_surgeries_activity_review\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if orthopedic_surgeries_activity_review exists")
	}

	return exists, nil
}
